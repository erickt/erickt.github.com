<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Serialization | Chasing Rabbits]]></title>
  <link href="http://erickt.github.io/blog/categories/serialization/atom.xml" rel="self"/>
  <link href="http://erickt.github.io/"/>
  <updated>2015-03-31T22:24:42-07:00</updated>
  <id>http://erickt.github.io/</id>
  <author>
    <name><![CDATA[Erick Tryzelaar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Serde 0.3]]></title>
    <link href="http://erickt.github.io/blog/2015/03/31/serde-0-dot-3/"/>
    <updated>2015-03-31T19:57:37-07:00</updated>
    <id>http://erickt.github.io/blog/2015/03/31/serde-0-dot-3</id>
    <content type="html"><![CDATA[<p>I&rsquo;m happy to announce that I&rsquo;ve released
<a href="https://github.com/erickt/rust-serde">serde</a> 0.3 on
<a href="https://crates.io/crates/serde">crates.io</a> today.  For those unfamiliar with
serde, it&rsquo;s a generic serialization framework, much like
<a href="https://github.com/rust-lang/rustc-serialize/">rustc-serialize</a>, but much more
powerful. Check out my <a href="http://erickt.github.io/blog/categories/serialization/">serialization series</a>
if you&rsquo;re interested in serde&rsquo;s original development.</p>

<p>There&rsquo;s been a ton of work since 0.2. Here are the highlights:</p>

<ul>
<li><p>Ported over from std::old_io to std::io. There is a bit of a performance hit
when serializing to <code>&amp;mut [u8]</code>, although it&rsquo;s really not that bad. In my goser
benchmarks, previously it ran in 373 MB/s, but now it&rsquo;s running at 260 MB/s.
However, this hasn&rsquo;t impacted the <code>Vec&lt;u8&gt;</code> serialization performance, nor
deserialization performance.</p></li>
<li><p>Much better JSON deserialization errors. Now <code>std::io::Error</code> is properly
propogated, and error locations are reported when a <code>Deserialize</code> raises an error.</p></li>
<li><p>Merged <code>serde::ser::Serializer</code> and <code>serde::ser::Visitor</code>.</p></li>
<li><p>Renamed <code>serde::ser::Serialize::visit</code> to <code>serde::ser::Serialize::serialize</code>.</p></li>
<li><p>Replaced <code>serde::ser::{Seq,Map}Visitor::size_hint</code> with a <code>len()</code> method that
returns an optional length. This has a little stronger emphasis that we either
need an exactly length or no length. Formats that need an exact length should
make sure to verify the length passed in matches the actual amount of values
serialized.</p></li>
<li><p><code>serde::json</code> now deserializes missing values as a <code>()</code>.</p></li>
<li><p>Finished implementing <code>#[derive(Serialize, Deserialize)]</code> for all struct and
enum forms.</p></li>
<li><p>Ported <code>serde_macros</code> over to <a href="https://github.com/erickt/rust-aster">aster</a>
and <a href="https://github.com/erickt/rust-quasi">quasi</a>, which simplies code
generation.</p></li>
<li><p>Removed the unnessary <code>first</code> argument from <code>visit_{seq,map}_elt</code>.</p></li>
<li><p>Rewrote enum deserializations to not require allocations. Oddly enough this
is a tad slower than the allocation form. I suspect it&rsquo;s coming from the
function calls not getting inlined away.</p></li>
<li><p>Allowed enum serialization and deserialization to support more than one
variant.</p></li>
<li><p>Allowed <code>Deserialize</code> types to hint that it&rsquo;s expecting a sequence or a map.</p></li>
<li><p>Allowed maps to be deserialized from a <code>()</code>.</p></li>
<li><p>Added a <code>serde::bytes::{Bytes,ByteBuf}</code>, which wrap <code>&amp;[u8]</code>/<code>Vec&lt;u8&gt;</code> to allow
some formats to encode these values more efficiently than generic sequences.</p></li>
<li><p>Added <code>serde::de::value</code>, which contains some helper deserializers to
deserialize from a Rust type.</p></li>
<li><p>Added impls for most collection types in the standard library.</p></li>
</ul>


<p>Thanks everyone that&rsquo;s helped out with this release!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rewriting Rust Serialization: Part 4: Serde2 Is Ready!]]></title>
    <link href="http://erickt.github.io/blog/2015/02/16/rewriting-rust-serialization-there-can-be-only-one-serde/"/>
    <updated>2015-02-16T07:32:54-08:00</updated>
    <id>http://erickt.github.io/blog/2015/02/16/rewriting-rust-serialization-there-can-be-only-one-serde</id>
    <content type="html"><![CDATA[<p>It&rsquo;s been a while, hasn&rsquo;t it? Here&rsquo;s
<a href="http://erickt.github.io/blog/2014/10/28/serialization/">part 1</a>,
<a href="http://erickt.github.io/blog/2014/11/03/performance/">part 2</a>,
<a href="http://erickt.github.io/blog/2014/11/03/performance/">part 2.1</a>,
<a href="http://erickt.github.io/blog/2014/11/03/performance/">part 2.2</a>,
<a href="http://erickt.github.io/blog/2014/12/13/rewriting-rust-serialization/">part 3</a>, and
<a href="http://erickt.github.io/blog/2014/12/13/performance-digression/">part 3.1</a>
if you want to catch up.</p>

<h2>Serde Version 2</h2>

<p>Well it&rsquo;s a long time coming, but serde2 is finally in a mostly usable
position! If you recall from
<a href="http://erickt.github.io/blog/2014/12/13/rewriting-rust-serialization/">part 3</a>,
one of the problems with serde1 is that we&rsquo;re paying a lot for tagging our
types, and it&rsquo;s really hurting us on the deserialization side of things. So
there&rsquo;s one other pattern that we can use that allows for lookahead that
doesn&rsquo;t need tags: visitors. A year or so ago I rewrote our generic hashing
framework to use the visitor pattern to great success. <code>serde2</code> came out of
experiments to see if I could do the same thing here. It turned out that it was
a really elegant approach.</p>

<h3>Serialize</h3>

<p>It all starts with a type that we want to serialize:</p>

<pre><code class="rust">pub trait Serialize {
    fn visit&lt;
        V: Visitor,
    &gt;(&amp;self, visitor: &amp;mut V) -&gt; Result&lt;V::Value, V::Error&gt;;
}
</code></pre>

<p>(Aside: while I&rsquo;d rather use <code>where</code> here for this type parameter, that would
force me to write <code>&lt;V as Visitor&gt;::Value&gt;</code> due to
<a href="https://github.com/rust-lang/rust/issues/20300">#20300</a>).</p>

<p>This <code>Visitor</code> trait then looks like:</p>

<pre><code class="rust">pub trait Visitor {
    type Value;
    type Error;

    fn visit_unit(&amp;mut self) -&gt; Result&lt;Self::Value, Self::Error&gt;;

    #[inline]
    fn visit_named_unit(&amp;mut self, _name: &amp;str) -&gt; Result&lt;Self::Value, Self::Error&gt; {
        self.visit_unit()
    }


    fn visit_bool(&amp;mut self, v: bool) -&gt; Result&lt;Self::Value, Self::Error&gt;;

    ...
}
</code></pre>

<p>So the implementation for a <code>bool</code> then looks like:</p>

<pre><code class="rust">impl Serialize for bool {
    #[inline]
    fn visit&lt;
        V: Visitor,
    &gt;(&amp;self, visitor: &amp;mut V) -&gt; Result&lt;V::Value, V::Error&gt; {
        visitor.visit_bool(*self)
    }
}
</code></pre>

<p>Things get more interesting when we get to compound structures like a sequence.
Here&rsquo;s <code>Visitor</code> again. It needs to both be able to visit the overall structure
as well as each item:</p>

<pre><code class="rust">    ...

    fn visit_seq&lt;V&gt;(&amp;mut self, visitor: V) -&gt; Result&lt;Self::Value, Self::Error&gt;
        where V: SeqVisitor;

    fn visit_seq_elt&lt;T&gt;(&amp;mut self,
                        first: bool,
                        value: T) -&gt; Result&lt;Self::Value, Self::Error&gt;
        where T: Serialize;

    ...
}
</code></pre>

<p>We also have this <code>SeqVisitor</code> trait that the type to serialize provides. It
really just looks like an <code>Iterator</code>, but the type parameter has been moved to
the <code>visit</code> method so that it can return different types:</p>

<pre><code class="rust">pub trait SeqVisitor {
    fn visit&lt;
        V: Visitor,
    &gt;(&amp;mut self, visitor: &amp;mut V) -&gt; Result&lt;Option&lt;V::Value&gt;, V::Error&gt;;

    #[inline]
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (0, None)
    }
}
</code></pre>

<p>Finally, to implement this for a type like <code>&amp;[T]</code> we create an
<code>Iterator</code>-to-<code>SeqVisitor</code> adaptor and pass it to the visitor, which then in
turn visits each item:</p>

<pre><code class="rust">pub struct SeqIteratorVisitor&lt;Iter&gt; {
    iter: Iter,
    first: bool,
}

impl&lt;T, Iter: Iterator&lt;Item=T&gt;&gt; SeqIteratorVisitor&lt;Iter&gt; {
    #[inline]
    pub fn new(iter: Iter) -&gt; SeqIteratorVisitor&lt;Iter&gt; {
        SeqIteratorVisitor {
            iter: iter,
            first: true,
        }
    }
}

impl&lt;
    T: Serialize,
    Iter: Iterator&lt;Item=T&gt;,
&gt; SeqVisitor for SeqIteratorVisitor&lt;Iter&gt; {
    #[inline]
    fn visit&lt;
        V: Visitor,
    &gt;(&amp;mut self, visitor: &amp;mut V) -&gt; Result&lt;Option&lt;V::Value&gt;, V::Error&gt; {
        let first = self.first;
        self.first = false;

        match self.iter.next() {
            Some(value) =&gt; {
                let value = try!(visitor.visit_seq_elt(first, value));
                Ok(Some(value))
            }
            None =&gt; Ok(None),
        }
    }

    #[inline]
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        self.iter.size_hint()
    }
}

impl&lt;
    'a,
    T: Serialize,
&gt; Serialize for &amp;'a [T] {
    #[inline]
    fn visit&lt;
        V: Visitor,
    &gt;(&amp;self, visitor: &amp;mut V) -&gt; Result&lt;V::Value, V::Error&gt; {
        visitor.visit_seq(SeqIteratorVisitor::new(self.iter()))
    }
}
</code></pre>

<p><code>SeqIteratorVisitor</code> is publically exposed, so it should be easy to use it with
custom data structures. Maps follow the same pattern (and also expose
<code>MapIteratorVisitor</code>), but each item instead uses <code>visit_visit_map_elt(first,
key, value)</code>.  Tuples, struct tuples, and tuple enum variants are all really
just named sequences. Likewise, structs and struct enum variants are just named
maps.</p>

<p>Because struct implementations are so common, here&rsquo;s an example how to do it:</p>

<pre><code class="rust">struct Point {
    x: i32,
    y: i32,
}

struct PointVisitor&lt;'a&gt; {
    state: u32,
    value: &amp;'a Point,
}

impl&lt;'a&gt; MapVisitor for PointVisitor&lt;'a&gt; {
    fn visit&lt;
        V: Visitor,
    &gt;(&amp;mut self, visitor: &amp;mut V) -&gt; Result&lt;V::Value, V::Error&gt; {
        match self.state {
            0 =&gt; {
                self.state += 1;
                Ok(Some(try!(visitor.visit_map_elt(true, "x", &amp;self.x))))
            }
            1 =&gt; {
                self.state += 1;
                Ok(Some(try!(visitor.visit_map_elt(true, "y", &amp;self.y))))
            }
            _ =&gt; Ok(None),
        }
    }
}

impl Serialize for Point {
    fn visit&lt;
        V: Visitor,
    &gt;(&amp;self, visitor: &amp;mut V) -&gt; Result&lt;V::Value, V::Error&gt; {
        visit_named_map("Point", PointVisitor {
            state: 0,
            value: self,
        })
    }
}
</code></pre>

<p>Fortunately <code>serde2</code> also comes with a <code>#[derive_serialize]</code> macro so you don&rsquo;t
need to write this out by hand if you don&rsquo;t want to.</p>

<h3>Serializer</h3>

<p>Now to actually build a serializer. We start with a trait:</p>

<pre><code class="rust">pub trait Serializer {
    type Value;
    type Error;

    fn visit&lt;T&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;Self::Value, Self::Error&gt;
        where T: Serialize;
}
</code></pre>

<p>It&rsquo;s the responsibility of the serializer to create a visitor and then pass it
to the type. Oftentimes the serializer also implements <code>Visitor</code>, but it&rsquo;s not
required. Here&rsquo;s a snippet of the JSON serializer visitor:</p>

<pre><code class="rust">struct Visitor&lt;'a, W: 'a&gt; {
    writer: &amp;'a mut W,
}

impl&lt;'a, W: Writer&gt; Visitor for Visitor&lt;'a, W&gt; {
    type Value = ();
    type Error = io::Error;

    fn visit_unit(&amp;mut self) -&gt; IoResult&lt;()&gt; {
        self.writer.write_all(b"null")
    }

    #[inline]
    fn visit_bool(&amp;mut self, value: bool) -&gt; IoResult&lt;()&gt; {
        if value {
            self.writer.write_all(b"true")
        } else {
            self.writer.write_all(b"false")
        }
    }

    #[inline]
    fn visit_isize(&amp;mut self, value: isize) -&gt; IoResult&lt;()&gt; {
        write!(self.writer, "{}", value)
    }

    ...

    #[inline]
    fn visit_map&lt;V&gt;(&amp;mut self, mut visitor: V) -&gt; IoResult&lt;()&gt;
        where V: ser::MapVisitor,
    {
        try!(self.writer.write_all(b"{"));

        while let Some(()) = try!(visitor.visit(self)) { }

        self.writer.write_all(b"}")
    }

    #[inline]
    fn visit_map_elt&lt;K, V&gt;(&amp;mut self, first: bool, key: K, value: V) -&gt; IoResult&lt;()&gt;
        where K: ser::Serialize,
              V: ser::Serialize,
    {
        if !first {
            try!(self.writer.write_all(b","));
        }

        try!(key.visit(self));
        try!(self.writer.write_all(b":"));
        value.visit(self)
    }
}
</code></pre>

<p>Hopefully it is pretty straight forward.</p>

<h2>Deserialization</h2>

<p>Now serialization is the easy part. Deserialization is where it always gets
more tricky. We follow a similar pattern as serialization. A deserializee
creates a visitor which accepts any type (most resulting in an error), and
passes it to a deserializer. This deserializer then extracts it&rsquo;s next value
from it&rsquo;s stream and passes it to the visitor, which then produces the actual
type.</p>

<p>It&rsquo;s achingly close to the same pattern between a serializer and a serializee,
but as hard as I tried, I couldn&rsquo;t unify the two. The error semantics are
different. In serialization, you want the serializer (which creates the
visitor) to define the error. In deserialization, you want the deserializer
which consumes the visitor to define the error.</p>

<p>Let&rsquo;s start first with <code>Error</code>. As opposed to serialization, when we&rsquo;re
deserializing we can error both in the <code>Deserializer</code> if there is a parse
error, or in the <code>Deserialize</code> if it&rsquo;s received an unexpected value. We do this
with an <code>Error</code> trait, which allows a deserializee to generically create the
few errors it needs:</p>

<pre><code class="rust">pub trait Error {
    fn syntax_error() -&gt; Self;

    fn end_of_stream_error() -&gt; Self;

    fn missing_field_error(&amp;'static str) -&gt; Self;
}
</code></pre>

<p>Now the <code>Deserialize</code> trait, which looks similar to <code>Serialize</code>:</p>

<pre><code class="rust">pub trait Deserialize {
    fn deserialize&lt;
        D: Deserializer,
    &gt;(deserializer: &amp;mut D) -&gt; Result&lt;Self, D::Error&gt;;
}
</code></pre>

<p>The <code>Visitor</code> also looks like the serialization <code>Visitor</code>, except for the
methods error by default.</p>

<pre><code class="rust">pub trait Visitor {
    type Value;

    fn visit_bool&lt;
        E: Error,
    &gt;(&amp;mut self, _v: bool) -&gt; Result&lt;Self::Value, E&gt; {
        Err(Error::syntax_error())
    }

    fn visit_isize&lt;
        E: Error,
    &gt;(&amp;mut self, v: isize) -&gt; Result&lt;Self::Value, E&gt; {
        self.visit_i64(v as i64)
    }

    ...
}
</code></pre>

<p>Sequences and Maps are also a little different:</p>

<pre><code class="rust">pub trait Visitor {
    ...

    fn visit_seq&lt;
        V: SeqVisitor,
    &gt;(&amp;mut self, _visitor: V) -&gt; Result&lt;Self::Value, V::Error&gt; {
        Err(Error::syntax_error())
    }

    fn visit_map&lt;
        V: MapVisitor,
    &gt;(&amp;mut self, _visitor: V) -&gt; Result&lt;Self::Value, V::Error&gt; {
        Err(Error::syntax_error())
    }

    ...
}

pub trait SeqVisitor {
    type Error: Error;

    fn visit&lt;
        T: Deserialize,
    &gt;(&amp;mut self) -&gt; Result&lt;Option&lt;T&gt;, Self::Error&gt;;

    fn end(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt;;

    #[inline]
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (0, None)
    }
}

pub trait MapVisitor {
    type Error: Error;

    #[inline]
    fn visit&lt;
        K: Deserialize,
        V: Deserialize,
    &gt;(&amp;mut self) -&gt; Result&lt;Option&lt;(K, V)&gt;, Self::Error&gt; {
        match try!(self.visit_key()) {
            Some(key) =&gt; {
                let value = try!(self.visit_value());
                Ok(Some((key, value)))
            }
            None =&gt; Ok(None)
        }
    }

    fn visit_key&lt;
        K: Deserialize,
    &gt;(&amp;mut self) -&gt; Result&lt;Option&lt;K&gt;, Self::Error&gt;;

    fn visit_value&lt;
        V: Deserialize,
    &gt;(&amp;mut self) -&gt; Result&lt;V, Self::Error&gt;;

    fn end(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt;;

    #[inline]
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (0, None)
    }
}
</code></pre>

<p>Here is an example struct deserializer. Structs are deserialized as a map, but
since maps are unordered, we need a simple state machine to extract the values.
In order to get the keys, we just create an enum for the fields, and a custom
deserializer to convert a string into a field without an allocation:</p>

<pre><code class="rust">struct Point {
    x: i32,
    y: i32,
}

impl Deserialize for Point {
    fn deserialize&lt;
        D: Deserializer,
    &gt;(deserializer: &amp;mut D) -&gt; Result&lt;Point, D::Error&gt; {
        enum Field {
            x,
            y,
        }

        struct FieldVisitor;

        impl Visitor for FieldVisitor {
            type Value = Field;

            fn visit_str&lt;
                E: Error,
            &gt;(&amp;mut self, value: &amp;str) -&gt; Result&lt;Field, E&gt; {
                match value {
                    "x" =&gt; Ok(Field::x),
                    "y" =&gt; Ok(Field::y),
                    _ =&gt; Err(Error::syntax_error()),
                }
            }
        }

        impl Deserialize for Field {
            fn deserialize&lt;
                D: Deserializer,
            &gt;(state: &amp;mut D) -&gt; Result&lt;Field, D::Error&gt; {
                state.visit(&amp;mut FieldVisitor)
            }
        }

        struct Visitor;

        impl Visitor for Visitor {
            type Value = Point;

            fn visit_map&lt;
                V: MapVisitor,
            &gt;(&amp;mut self, mut visitor: V) -&gt; Result&lt;Point, V::Error&gt; {
                {
                    let mut x = None;
                    let mut y = None;

                    while let Some(key) = try!(visitor.visit_key()) {
                        match key {
                            Field::x =&gt; {
                                x = Some(try!(visitor.visit_value()));
                            }
                            Field::y =&gt; {
                                y = Some(try!(visitor.visit_value()));
                            }
                        }
                    }

                    let x = match x {
                        Some(x) =&gt; x,
                        None =&gt; {
                            return Err(Error::missing_field_error("x"));
                        }
                    };
                    let y = match y {
                        Some(y) =&gt; y,
                        None =&gt; {
                            return Err(Error::missing_field_error("y"));
                        }
                    };

                    Ok(Point {
                        x: x,
                        y: y,
                    })
                }
            }

            fn visit_named_map&lt;
                V: MapVisitor,
            &gt;(&amp;mut self, name: &amp;str, visitor: V) -&gt; Result&lt;Point, V::Error&gt; {
                if name == "Point" {
                    self.visit_map(visitor)
                } else {
                    Err(Error::syntax_error())
                }
            }
        }

        deserializer.visit(&amp;mut Visitor)
    }
}
</code></pre>

<p>It&rsquo;s a little more complicated, but once again there is
<code>#[derive_deserialize]</code>, which does all this work for you.</p>

<h3>Deserializer</h3>

<p>Deserializers then follow the same pattern as serializers. The one difference
is that we need to provide a special hook for <code>Option&lt;T&gt;</code> types so formats like
JSON can treat <code>null</code> types as options.</p>

<pre><code class="rust">pub trait Deserializer {
    type Error: Error;

    fn visit&lt;
        V: Visitor,
    &gt;(&amp;mut self, visitor: &amp;mut V) -&gt; Result&lt;V::Value, Self::Error&gt;;

    /// The `visit_option` method allows a `Deserialize` type to inform the
    /// `Deserializer` that it's expecting an optional value. This allows
    /// deserializers that encode an optional value as a nullable value to
    /// convert the null value into a `None`, and a regular value as
    /// `Some(value)`.
    #[inline]
    fn visit_option&lt;
        V: Visitor,
    &gt;(&amp;mut self, visitor: &amp;mut V) -&gt; Result&lt;V::Value, Self::Error&gt; {
        self.visit(visitor)
    }
}
</code></pre>

<h2>Performance</h2>

<p>So how does it perform? Here&rsquo;s the serialization benchmarks, with yet another
ordering. This time sorted by the performance:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library                   </th>
<th> format                 </th>
<th> serialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> Rust     </td>
<td> capnproto-rust            </td>
<td> Cap&#8217;n Proto (unpacked) </td>
<td> 4226                 </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto              </td>
<td> Cap&#8217;n Proto            </td>
<td> 3824.20              </td>
</tr>
<tr>
<td> Rust     </td>
<td> bincode                   </td>
<td> Binary                 </td>
<td> 1020                 </td>
</tr>
<tr>
<td> Rust     </td>
<td> capnproto-rust            </td>
<td> Cap&#8217;n Proto (packed)   </td>
<td> 672                  </td>
</tr>
<tr>
<td> Go       </td>
<td> gogoprotobuf              </td>
<td> Protocol Buffers       </td>
<td> 596.78               </td>
</tr>
<tr>
<td> Rust     </td>
<td> rust-msgpack              </td>
<td> MessagePack            </td>
<td> 397                  </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serde2::json</strong> (&amp;[u8])  </td>
<td> <strong>JSON</strong>               </td>
<td> <strong>373</strong>              </td>
</tr>
<tr>
<td> Rust     </td>
<td> rust-protobuf             </td>
<td> Protocol Buffers       </td>
<td> 357                  </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson                 </td>
<td> JSON                   </td>
<td> 316                  </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serde2::json</strong> (Custom) </td>
<td> <strong>JSON</strong>               </td>
<td> <strong>306</strong>              </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serde2::json</strong> (Vec)    </td>
<td> <strong>JSON</strong>               </td>
<td> <strong>288</strong>              </td>
</tr>
<tr>
<td> Rust     </td>
<td> serde::json (Custom)      </td>
<td> JSON                   </td>
<td> 244                  </td>
</tr>
<tr>
<td> Rust     </td>
<td> serde::json (&amp;[u8])       </td>
<td> JSON                   </td>
<td> 222                  </td>
</tr>
<tr>
<td> Go       </td>
<td> goprotobuf                </td>
<td> Protocol Buffers       </td>
<td> 214.68               </td>
</tr>
<tr>
<td> Rust     </td>
<td> serde::json (Vec)         </td>
<td> JSON                   </td>
<td> 149                  </td>
</tr>
<tr>
<td> Go       </td>
<td> ffjson                    </td>
<td> JSON                   </td>
<td> 147.37               </td>
</tr>
<tr>
<td> Rust     </td>
<td> serialize::json           </td>
<td> JSON                   </td>
<td> 183                  </td>
</tr>
<tr>
<td> Go       </td>
<td> encoding/json             </td>
<td> JSON                   </td>
<td> 80.49                </td>
</tr>
</tbody>
</table>


<p>I think it&rsquo;s fair to say that on at least this benchmark we&rsquo;ve hit our
performance numbers. Writing to a preallocated buffer with <code>BufWriter</code> is 18%
<em>faster</em> than <a href="https://github.com/miloyip/rapidjson">rapidjson</a> (although to be
fair they are allocating). Our <code>Vec&lt;u8&gt;</code> writer comes in 12% slower. What&rsquo;s
interesting is this custom Writer. It turns out LLVM is still having trouble
lowering our generic <code>Vec::push_all</code> into a <code>memcpy</code>. This Writer variant
however is able to get us to rapidjson&rsquo;s level:</p>

<pre><code class="rust">fn push_all_bytes(dst: &amp;mut Vec&lt;u8&gt;, src: &amp;[u8]) {
    let dst_len = dst.len();
    let src_len = src.len();

    dst.reserve(src_len);

    unsafe {
        // we would have failed if `reserve` overflowed.
        dst.set_len(dst_len + src_len);

        ::std::ptr::copy_nonoverlapping_memory(
            dst.as_mut_ptr().offset(dst_len as isize),
            src.as_ptr(),
            src_len);
    }
}

struct MyMemWriter1 {
    buf: Vec&lt;u8&gt;,
}

impl Writer for MyMemWriter1 {
    #[inline]
    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; IoResult&lt;()&gt; {
        push_all_bytes(&amp;mut self.buf, buf);
        Ok(())
    }
}
</code></pre>

<p>Deserialization we do much better than serde because we aren&rsquo;t passing around
all those tags, but we have a ways to catch up to rapidjson. Still, being just 37%
slower than the fastest JSON deserializer makes me feel pretty proud.</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library          </th>
<th> format                  </th>
<th> deserialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> Rust     </td>
<td> capnproto-rust   </td>
<td> Cap&#8217;n Proto (unpacked)  </td>
<td> 2123                   </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto     </td>
<td> Cap&#8217;n Proto (zero copy) </td>
<td> 1407.95                </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto     </td>
<td> Cap&#8217;n Proto             </td>
<td> 711.77                 </td>
</tr>
<tr>
<td> Rust     </td>
<td> capnproto-rust   </td>
<td> Cap&#8217;n Proto (packed)    </td>
<td> 529                    </td>
</tr>
<tr>
<td> Go       </td>
<td> gogoprotobuf     </td>
<td> Protocol Buffers        </td>
<td> 272.68                 </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson        </td>
<td> JSON (sax)              </td>
<td> 189                    </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson        </td>
<td> JSON (dom)              </td>
<td> 162                    </td>
</tr>
<tr>
<td> Rust     </td>
<td> bincode          </td>
<td> Binary                  </td>
<td> 142                    </td>
</tr>
<tr>
<td> Rust     </td>
<td> rust-protobuf    </td>
<td> Protocol Buffers        </td>
<td> 141                    </td>
</tr>
<tr>
<td> Rust     </td>
<td> rust-msgpack     </td>
<td> MessagePack             </td>
<td> 138                    </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serde2::json</strong> </td>
<td> <strong>JSON</strong>                </td>
<td> <strong>122</strong>                </td>
</tr>
<tr>
<td> Go       </td>
<td> ffjson           </td>
<td> JSON                    </td>
<td> 95.06                  </td>
</tr>
<tr>
<td> Go       </td>
<td> goprotobuf       </td>
<td> Protocol Buffers        </td>
<td> 79.78                  </td>
</tr>
<tr>
<td> Rust     </td>
<td> serde::json      </td>
<td> JSON                    </td>
<td> 67                     </td>
</tr>
<tr>
<td> Rust     </td>
<td> serialize::json  </td>
<td> JSON                    </td>
<td> 25                     </td>
</tr>
<tr>
<td> Go       </td>
<td> encoding/json    </td>
<td> JSON                    </td>
<td> 22.79                  </td>
</tr>
</tbody>
</table>


<h2>Conclusion</h2>

<p>What a long trip it&rsquo;s been! I hope you enjoyed it. While there are still
a few things left to port over from serde1 to serde2 (like the JSON pretty
printer), and some things probably should be renamed, I&rsquo;m happy with the design
so I think it&rsquo;s in a place where people can start using it now. Please let me
know how it goes!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rewriting Rust Serialization, Part 3.1: Another Performance Digression]]></title>
    <link href="http://erickt.github.io/blog/2014/12/13/performance-digression/"/>
    <updated>2014-12-13T18:35:08-08:00</updated>
    <id>http://erickt.github.io/blog/2014/12/13/performance-digression</id>
    <content type="html"><![CDATA[<p>Wow, home stretch! Here&rsquo;s the rest of the series if you want to catch up:
<a href="http://erickt.github.io/blog/2014/10/28/serialization/">part 1</a>,
<a href="http://erickt.github.io/blog/2014/11/03/performance/">part 2</a>,
<a href="http://erickt.github.io/blog/2014/11/03/performance/">part 2.1</a>,
<a href="http://erickt.github.io/blog/2014/11/03/performance/">part 2.2</a>, and
<a href="http://erickt.github.io/blog/2014/12/13/rewriting-rust-serialization/">part 3</a>.</p>

<p>Overall <code>serde</code>&rsquo;s approach for serialization works out pretty well. One thing I
forgot to include in the last post was that I also have two benchmarks that are
not using <code>serde</code>, but are just safely reading and writing values.  Assuming I
haven&rsquo;t missed anything, they should be the upper limit in performance we can
get out of any serialization framework: Here&rsquo;s
<a href="https://github.com/erickt/rust-serde/blob/master/benches/bench_log.rs#L1021">serialization</a>:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library                        </th>
<th> serialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> <strong>rust</strong> </td>
<td> <strong>max without string escapes</strong> </td>
<td> <strong>353</strong>              </td>
</tr>
<tr>
<td> c++      </td>
<td> rapidjson                      </td>
<td> 304                  </td>
</tr>
<tr>
<td> <strong>rust</strong> </td>
<td> <strong>max with string escape</strong>     </td>
<td> <strong>234</strong>              </td>
</tr>
<tr>
<td> rust     </td>
<td> serde::json                    </td>
<td> 201                  </td>
</tr>
<tr>
<td> rust     </td>
<td> serialize::json                </td>
<td> 147                  </td>
</tr>
<tr>
<td> go       </td>
<td> ffjson                         </td>
<td> 147                  </td>
</tr>
</tbody>
</table>


<p>So beyond optimizing string escaping, <code>serde::json</code> is only 14% slower than the
zero-cost version and 34% slower than <code>rapidjson</code>.</p>

<p><a href="https://github.com/erickt/rust-serde/blob/master/benches/bench_log.rs#L1613">Deserialization</a>,
on the other hand, still has a ways to go:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library                         </th>
<th> deserialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> rust     </td>
<td> rapidjson (SAX)                 </td>
<td> 189                    </td>
</tr>
<tr>
<td> c++      </td>
<td> rapidjson (DOM)                 </td>
<td> 162                    </td>
</tr>
<tr>
<td> <strong>rust</strong> </td>
<td> <strong>max with Iterator&lt;u8&gt;</strong> </td>
<td> <strong>152</strong>                </td>
</tr>
<tr>
<td> go       </td>
<td> ffjson                          </td>
<td> 95                     </td>
</tr>
<tr>
<td> <strong>rust</strong> </td>
<td> <strong>max with Reader</strong>             </td>
<td> <strong>78</strong>                 </td>
</tr>
<tr>
<td> rust     </td>
<td> serde::json                     </td>
<td> 73                     </td>
</tr>
<tr>
<td> rust     </td>
<td> serialize::json                 </td>
<td> 24                     </td>
</tr>
</tbody>
</table>


<p>There are a couple interesting things here:</p>

<p>First, <code>serde::json</code> is built upon consuming from an <code>Iterator&lt;u8&gt;</code>, so we&rsquo;re
48% slower than our theoretical max, and 58% slower than <code>rapidjson</code>. It looks
like tagged tokens, while faster than the closures in <code>libserialize</code>, are still
pretty expensive.</p>

<p>Second, <code>ffjson</code> is beating us and they compile dramatically faster too. The
<a href="https://github.com/cloudflare/goser">goser</a> test suite takes about 0.54
seconds to compile, whereas mine takes about 30 seconds at <code>--opt-level=3</code>
(!!). Rust itself is only taking 1.5 seconds, the rest is spent in LLVM. With
no optimization, it compiles &ldquo;only&rdquo; in 5.6 seconds, and is 96% slower.</p>

<p>Third, <code>Reader</code> is a surprisingly expensive trait when dealing with a format
like JSON that need to read a byte at a time. It turns out we&rsquo;re not
<a href="https://github.com/rust-lang/rust/issues/19864">generating great code</a> for
types with padding. aatch has been working on fixing this though.</p>

<hr />

<p>Since I wrote that last section, I did a little more experimentation to try to
figure out why our serialization upper bound is 23% slower than rapidjson. And,
well, maybe I found it?</p>

<table>
<thead>
<tr>
<th>                                </th>
<th> serialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> serde::json with a MyMemWriter </td>
<td> 346                  </td>
</tr>
<tr>
<td> serde::json with a Vec<u8>     </td>
<td> 247                  </td>
</tr>
</tbody>
</table>


<p>All I did with <code>MyMemWriter</code> is copy the <code>Vec::&lt;u8&gt;</code> implementation of <code>Writer</code>
into the local codebase:</p>

<pre><code class="rust">struct MyMemWriter0 {
    buf: Vec&lt;u8&gt;,
}

impl MyMemWriter0 {
    pub fn with_capacity(cap: uint) -&gt; MyMemWriter0 {
        MyMemWriter0 {
            buf: Vec::with_capacity(cap)
        }
    }
}

impl Writer for MyMemWriter0 {
    #[inline]
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::IoResult&lt;()&gt; {
        self.buf.push_all(buf);
        Ok(())
    }
}

#[bench]
fn bench_serializer_my_mem_writer0(b: &amp;mut Bencher) {
    let log = Log::new();
    let json = json::to_vec(&amp;log);
    b.bytes = json.len() as u64;

    let mut wr = MyMemWriter0::with_capacity(1024);

    b.iter(|| {
        wr.buf.clear();

        let mut serializer = json::Serializer::new(wr.by_ref());
        log.serialize(&amp;mut serializer).unwrap();
        let _json = serializer.unwrap();
    });
}

#[bench]
fn bench_serializer_vec(b: &amp;mut Bencher) {
    let log = Log::new();
    let json = json::to_vec(&amp;log);
    b.bytes = json.len() as u64;

    let mut wr = Vec::with_capacity(1024);

    b.iter(|| {
        wr.clear();

        let mut serializer = json::Serializer::new(wr.by_ref());
        log.serialize(&amp;mut serializer).unwrap();
        let _json = serializer.unwrap();
    });
}
</code></pre>

<p>Somehow it&rsquo;s not enough to just mark <code>Vec::write</code> as
<code>#[inline]</code>, having it in the same file gave LLVM enough information to
optimize it&rsquo;s overhead away. Even using <code>#[inline(always)]</code> on <code>Vec::write</code> and
<code>Vec::push_all</code> isn&rsquo;t able to get the same increase, so I&rsquo;m not sure how to
replicate this in the general case.</p>

<p>Also interesting is <code>bench_serializer_slice</code>, which uses <code>BufWriter</code>.</p>

<table>
<thead>
<tr>
<th>                                </th>
<th> serialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> serde::json with a BufWriter   </td>
<td> 342                  </td>
</tr>
</tbody>
</table>


<pre><code class="rust">#[bench]
fn bench_serializer_slice(b: &amp;mut Bencher) {
    let log = Log::new();
    let json = json::to_vec(&amp;log);
    b.bytes = json.len() as u64;

    let mut buf = [0, .. 1024];

    b.iter(|| {
        for item in buf.iter_mut(){ *item = 0; }
        let mut wr = std::io::BufWriter::new(&amp;mut buf);

        let mut serializer = json::Serializer::new(wr.by_ref());
        log.serialize(&amp;mut serializer).unwrap();
        let _json = serializer.unwrap();
    });
}
</code></pre>

<hr />

<p>Another digression. Since I wrote the above, aatch has put out some PRs that
should help speed up enums.
<a href="https://github.com/rust-lang/rust/pull/19898">19898</a> and
<a href="https://github.com/rust-lang/rust/pull/20060">#20060</a> and was able to optimize
the padding out of enums and fix an issue with returns generating bad code. In
my <a href="https://github.com/rust-lang/rust/issues/19864">bug from earlier</a>
his patches were able to speed up my benchmark returning an
<code>Result&lt;(), IoError&gt;</code> from running at 40MB/s to 88MB/s. However, if we&rsquo;re able
to reduce <code>IoError</code> down to a word, we get the performance up to 730MB/s! We
also might get enum compression, so a type like <code>Result&lt;(), IoError&gt;</code> then
would speed up to 1200MB/s! I think going in this direction is going to really
help speed things up.</p>

<hr />

<p>That was taking a while, so until next time!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rewriting Rust Serialization, Part 3: Introducing Serde]]></title>
    <link href="http://erickt.github.io/blog/2014/12/13/rewriting-rust-serialization/"/>
    <updated>2014-12-13T14:40:18-08:00</updated>
    <id>http://erickt.github.io/blog/2014/12/13/rewriting-rust-serialization</id>
    <content type="html"><![CDATA[<p>There&rsquo;s been a long digression over the past month
(<a href="http://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/">possible kernel bugs</a>,
<a href="http://erickt.github.io/blog/2014/11/22/benchmarking-is-confusing/">benchmarking Writers</a>,
and
<a href="https://github.com/rust-lang/rust/pull/19574">don&rsquo;t believe in magic, folks</a>), but I&rsquo;m back
into serialization. Woo! Here&rsquo;s
<a href="http://erickt.github.io/blog/2014/10/28/serialization/">part 1</a>
<a href="http://erickt.github.io/blog/2014/11/03/performance/">part 2</a>,
<a href="http://erickt.github.io/blog/2014/11/03/performance/">part 2.1</a>, and
<a href="http://erickt.github.io/blog/2014/11/03/performance/">part 2.2</a> if you need
to catch up.</p>

<p>So <code>libserialize</code> has some pretty serious downsides. It&rsquo;s slow, it&rsquo;s got this
weird recursive closure thing going on, and it can&rsquo;t even represent enum types
like a <code>serialize::json::Json</code>. We need a new solution, and while I was at it,
we ended up with two: <a href="https://github.com/erickt/rust-serde">serde</a> and
<a href="https://github.com/erickt/rust-serde/tree/master/serde2">serde2</a>. Both are
different approaches to trying to address these problems. The biggest one being
the type representation problem.</p>

<h2>Serde Version 1</h2>

<h3>Deserialization</h3>

<p>I want to start with deserialization first, as that&rsquo;s really the interesting
bit. To repeat myself a little bit from
<a href="https://erickt.github.io/blog/2014/10/28/serialization/">part 1</a>,
here is a generic json <code>Value</code> enum:</p>

<pre><code class="rust">pub enum Value {
    I64(i64),
    U64(u64),
    F64(f64),
    String(String),
    Boolean(bool),
    Array(Vec&lt;Value&gt;),
    Object(TreeMap&lt;String, Value&gt;),
    Null,
}
</code></pre>

<p>To deserialize a string like <code>[1, true]</code> into
<code>Array(vec![I64(1), Boolean(true)])</code>, we need to peek at one character ahead
(ignoring whitespace) in order to discover what is the type of the next value.
We then can use that knowledge to pick the right variant, and parse the next
value correctly. While I haven&rsquo;t formally studied this stuff, I believe this
can be more formally stated as <code>Value</code> requires at least a LL(1) grammar,
but since <code>libserialize</code> supports no lookahead, so at most it can handle LL(0)
grammars.</p>

<p>Since I was thinking of this problem in terms of grammars, I wanted to take a
page out of their book and implement generic deserialization in this style.
<code>serde::de::Deserializer</code>s are then an <code>Iterator&lt;serde::de::Token&gt;</code> lexer that
produces a token stream, and <code>serde::de::Deserialize</code>s are a parser that
consumes this stream to produce a value. Here&rsquo;s <code>serde::de::Token</code>, which can
represent nearly all the rust types:</p>

<pre><code class="rust">pub enum Token {
    Null,
    Bool(bool),
    Int(int),
    I8(i8),
    I16(i16),
    I32(i32),
    I64(i64),
    Uint(uint),
    U8(u8),
    U16(u16),
    U32(u32),
    U64(u64),
    F32(f32),
    F64(f64),
    Char(char),
    Str(&amp;'static str),
    String(String),

    Option(bool),     // true if the option has a value

    TupleStart(uint), // estimate of the number of values

    StructStart(
        &amp;'static str, // the struct name
        uint,         // estimate of the number of (string, value) pairs
    ),

    EnumStart(
        &amp;'static str, // the enum name
        &amp;'static str, // the variant name
        uint          // estimate of the number of values
    ),

    SeqStart(uint), // number of values

    MapStart(uint), // number of (value, value) pairs

    End,
}
</code></pre>

<p>The <code>serde::de::Deserialize</code> stream must generate tokens that follow this
grammar:</p>

<pre><code class="antlr">value ::= Null
        | Bool
        | Int
        | ...
        | option
        | tuple
        | struct
        | enum
        | sequence
        | map
        ;

option ::= Option value
         | Option
         ;

tuple := TupleStart value* End;

struct := StructStart (Str value)* End;

enum := EnumStart value* End;

sequence := SeqStart value* End;

map := MapStart (value value)* End;
</code></pre>

<p>For performance reasons, there is no separator in the compound grammar.</p>

<p>Finishing up this section are the actual traits, <code>Deserialize</code> and <code>Deserializer</code>:</p>

<pre><code class="rust">pub trait Deserialize&lt;D: Deserializer&lt;E&gt;, E&gt; {
    fn deserialize(d: &amp;mut D) -&gt; Result&lt;Self, E&gt; {
        let token = try!(d.expect_token());
        Deserialize::deserialize_token(d, token)
    }

    fn deserialize_token(d: &amp;mut D, token: Token) -&gt; Result&lt;Self, E&gt;;
}

pub trait Deserializer&lt;E&gt;: Iterator&lt;Result&lt;Token, E&gt;&gt; {
    /// Called when a `Deserialize` expected more tokens, but the
    /// `Deserializer` was empty.
    fn end_of_stream_error(&amp;mut self) -&gt; E;

    /// Called when a `Deserializer` was unable to properly parse the stream.
    fn syntax_error(&amp;mut self, token: Token, expected: &amp;'static [TokenKind]) -&gt; E;

    /// Called when a named structure or enum got a name that it didn't expect.
    fn unexpected_name_error(&amp;mut self, token: Token) -&gt; E;

    /// Called when a value was unable to be coerced into another value.
    fn conversion_error(&amp;mut self, token: Token) -&gt; E;

    /// Called when a `Deserialize` structure did not deserialize a field
    /// named `field`.
    fn missing_field&lt;
        T: Deserialize&lt;Self, E&gt;
    &gt;(&amp;mut self, field: &amp;'static str) -&gt; Result&lt;T, E&gt;;

    /// Called when a `Deserialize` has decided to not consume this token.
    fn ignore_field(&amp;mut self, _token: Token) -&gt; Result&lt;(), E&gt; {
        let _: IgnoreTokens = try!(Deserialize::deserialize(self));
        Ok(())
    }

    #[inline]
    fn expect_token(&amp;mut self) -&gt; Result&lt;Token, E&gt; {
        self.next().unwrap_or_else(|| Err(self.end_of_stream_error()))
    }

    ...
}
</code></pre>

<p>The <code>Deserialize</code> trait is kept pretty slim, and is how lookahead is
implemented. <code>Deserializer</code> is an enhanced <code>Iterator&lt;Result&lt;Token, E&gt;&gt;</code>, with
many helpful default methods. Here are them in action. First we&rsquo;ll start with
what&rsquo;s probably the simplest <code>Deserializer</code>, which just wraps a <code>Vec&lt;Token&gt;</code>:</p>

<pre><code class="rust">enum Error {
    EndOfStream,
    SyntaxError(Vec&lt;TokenKind&gt;),
    UnexpectedName,
    ConversionError,
    MissingField(&amp;'static str),
}

struct TokenDeserializer&lt;Iter&gt; {
    tokens: Iter,
}

impl&lt;Iter: Iterator&lt;Token&gt;&gt; TokenDeserializer&lt;Iter&gt; {
    fn new(tokens: Iter) -&gt; TokenDeserializer&lt;Iter&gt; {
        TokenDeserializer {
            tokens: tokens,
        }
    }
}

impl&lt;Iter: Iterator&lt;Token&gt;&gt; Iterator&lt;Result&lt;Token, Error&gt;&gt; for TokenDeserializer&lt;Iter&gt; {
    fn next(&amp;mut self) -&gt; option::Option&lt;Result&lt;Token, Error&gt;&gt; {
        self.tokens.next().map(|token| Ok(token))
    }
}

impl&lt;Iter: Iterator&lt;Token&gt;&gt; Deserializer&lt;Error&gt; for TokenDeserializer&lt;Iter&gt; {
    fn end_of_stream_error(&amp;mut self) -&gt; Error {
        Error::EndOfStream
    }

    fn syntax_error(&amp;mut self, _token: Token, expected: &amp;[TokenKind]) -&gt; Error {
        Error::SyntaxError(expected.to_vec())
    }

    fn unexpected_name_error(&amp;mut self, _token: Token) -&gt; Error {
        Error::UnexpectedName
    }

    fn conversion_error(&amp;mut self, _token: Token) -&gt; Error {
        Error::ConversionError
    }

    #[inline]
    fn missing_field&lt;
        T: Deserialize&lt;TokenDeserializer&lt;Iter&gt;, Error&gt;
    &gt;(&amp;mut self, field: &amp;'static str) -&gt; Result&lt;T, Error&gt; {
        Err(Error::MissingField(field))
    }
}
</code></pre>

<p>Overall it should be pretty straight forward. As usual, error handling makes
things a bit noisier, but hopefully it&rsquo;s not too onerous. Next is a
<code>Deserialize</code> for <code>bool</code>:</p>

<pre><code class="rust">impl&lt;D: Deserializer&lt;E&gt;, E&gt; Deserialize&lt;D, E&gt; for bool {
    #[inline]
    fn deserialize_token(d: &amp;mut D, token: Token) -&gt; Result&lt;bool, E&gt; {
        d.expect_bool(token)
    }
}

pub trait Deserializer&lt;E&gt;: Iterator&lt;Result&lt;Token, E&gt;&gt; {
    ...

    #[inline]
    fn expect_bool(&amp;mut self, token: Token) -&gt; Result&lt;bool, E&gt; {
        match token {
            Token::Bool(value) =&gt; Ok(value),
            token =&gt; {
                static EXPECTED_TOKENS: &amp;'static [TokenKind] = &amp;[
                    TokenKind::BoolKind,
                ];
                Err(self.syntax_error(token, EXPECTED_TOKENS))
            }
        }
    }


    ...
}
</code></pre>

<p>Simple! Sequences are a bit more tricky. Here&rsquo;s <code>Deserialize</code> a <code>Vec&lt;T&gt;</code>. We
use a helper adaptor <code>SeqDeserializer</code> to deserialize from all types that
implement <code>FromIterator</code>:</p>

<pre><code class="rust">impl&lt;
    D: Deserializer&lt;E&gt;,
    E,
    T: Deserialize&lt;D ,E&gt;
&gt; Deserialize&lt;D, E&gt; for Vec&lt;T&gt; {
    #[inline]
    fn deserialize_token(d: &amp;mut D, token: Token) -&gt; Result&lt;Vec&lt;T&gt;, E&gt; {
        d.expect_seq(token)
    }
}

pub trait Deserializer&lt;E&gt;: Iterator&lt;Result&lt;Token, E&gt;&gt; {
    ...

    #[inline]
    fn expect_seq&lt;
        T: Deserialize&lt;Self, E&gt;,
        C: FromIterator&lt;T&gt;
    &gt;(&amp;mut self, token: Token) -&gt; Result&lt;C, E&gt; {
        let len = try!(self.expect_seq_start(token));
        let mut err = None;

        let collection: C = {
            let d = SeqDeserializer {
                d: self,
                len: len,
                err: &amp;mut err,
            };

            d.collect()
        };

        match err {
            Some(err) =&gt; Err(err),
            None =&gt; Ok(collection),
        }
    }

    ...
}

struct SeqDeserializer&lt;'a, D: 'a, E: 'a&gt; {
    d: &amp;'a mut D,
    len: uint,
    err: &amp;'a mut Option&lt;E&gt;,
}

impl&lt;
    'a,
    D: Deserializer&lt;E&gt;,
    E,
    T: Deserialize&lt;D, E&gt;
&gt; Iterator&lt;T&gt; for SeqDeserializer&lt;'a, D, E&gt; {
    #[inline]
    fn next(&amp;mut self) -&gt; option::Option&lt;T&gt; {
        match self.d.expect_seq_elt_or_end() {
            Ok(next) =&gt; {
                self.len -= 1;
                next
            }
            Err(err) =&gt; {
                *self.err = Some(err);
                None
            }
        }
    }

    #[inline]
    fn size_hint(&amp;self) -&gt; (uint, option::Option&lt;uint&gt;) {
        (self.len, Some(self.len))
    }
}
</code></pre>

<p>Last is a struct deserializer. This relies on a simple state machine in order
to deserialize from out of order maps:</p>

<pre><code class="rust">struct Foo {
    a: (),
    b: uint,
    c: TreeMap&lt;String, Option&lt;char&gt;&gt;,
}

impl&lt;
    D: Deserializer&lt;E&gt;,
    E
&gt; Deserialize&lt;D, E&gt; for Foo {
    #[inline]
    fn deserialize_token(d: &amp;mut D, token: Token) -&gt; Result&lt;Foo, E&gt; {
        try!(d.expect_struct_start(token, "Foo"));

        let mut a = None;
        let mut b = None;
        let mut c = None;

        static FIELDS: &amp;'static [&amp;'static str] = &amp;["a", "b", "c"];

        loop {
            let idx = match try!(d.expect_struct_field_or_end(FIELDS)) {
                Some(idx) =&gt; idx,
                None =&gt; { break; }
            };

            match idx {
                Some(0) =&gt; { a = Some(try!(d.expect_struct_value())); }
                Some(1) =&gt; { b = Some(try!(d.expect_struct_value())); }
                Some(2) =&gt; { c = Some(try!(d.expect_struct_value())); }
                Some(_) =&gt; unreachable!(),
                None =&gt; { let _: IgnoreTokens = try!(Deserialize::deserialize(d)); }
            }
        }

        Ok(Foo { a: a.unwrap(), b: b.unwrap(), c: c.unwrap() })
    }
}
</code></pre>

<p>It&rsquo;s more complicated than <code>libserialize</code>&rsquo;s struct parsing, but it performs
much better because it can handle out of order maps without buffering tokens.</p>

<h3>Serialization</h3>

<p>Serialization&rsquo;s story is a much simpler one. Conceptually
<code>serde::ser::Serializer</code>/<code>serde::ser::Serialize</code> are inspired by the
deserialization story, but we don&rsquo;t need the tagged tokens because we already
know the types. Here are the traits:</p>

<pre><code class="rust">pub trait Serialize&lt;S: Serializer&lt;E&gt;, E&gt; {
    fn serialize(&amp;self, s: &amp;mut S) -&gt; Result&lt;(), E&gt;;
}

pub trait Serializer&lt;E&gt; {
    fn serialize_null(&amp;mut self) -&gt; Result&lt;(), E&gt;;

    fn serialize_bool(&amp;mut self, v: bool) -&gt; Result&lt;(), E&gt;;

    #[inline]
    fn serialize_int(&amp;mut self, v: int) -&gt; Result&lt;(), E&gt; {
        self.serialize_i64(v as i64)
    }

    #[inline]
    fn serialize_i8(&amp;mut self, v: i8) -&gt; Result&lt;(), E&gt; {
        self.serialize_i64(v as i64)
    }

    #[inline]
    fn serialize_i16(&amp;mut self, v: i16) -&gt; Result&lt;(), E&gt; {
        self.serialize_i64(v as i64)
    }

    #[inline]
    fn serialize_i32(&amp;mut self, v: i32) -&gt; Result&lt;(), E&gt; {
        self.serialize_i64(v as i64)
    }

    #[inline]
    fn serialize_i64(&amp;mut self, v: i64) -&gt; Result&lt;(), E&gt;;

    #[inline]
    fn serialize_uint(&amp;mut self, v: uint) -&gt; Result&lt;(), E&gt; {
        self.serialize_u64(v as u64)
    }

    #[inline]
    fn serialize_u8(&amp;mut self, v: u8) -&gt; Result&lt;(), E&gt; {
        self.serialize_u64(v as u64)
    }

    #[inline]
    fn serialize_u16(&amp;mut self, v: u16) -&gt; Result&lt;(), E&gt; {
        self.serialize_u64(v as u64)
    }

    #[inline]
    fn serialize_u32(&amp;mut self, v: u32) -&gt; Result&lt;(), E&gt; {
        self.serialize_u64(v as u64)
    }

    #[inline]
    fn serialize_u64(&amp;mut self, v: u64) -&gt; Result&lt;(), E&gt;;

    #[inline]
    fn serialize_f32(&amp;mut self, v: f32) -&gt; Result&lt;(), E&gt; {
        self.serialize_f64(v as f64)
    }

    fn serialize_f64(&amp;mut self, v: f64) -&gt; Result&lt;(), E&gt;;

    fn serialize_char(&amp;mut self, v: char) -&gt; Result&lt;(), E&gt;;

    fn serialize_str(&amp;mut self, v: &amp;str) -&gt; Result&lt;(), E&gt;;

    fn serialize_tuple_start(&amp;mut self, len: uint) -&gt; Result&lt;(), E&gt;;
    fn serialize_tuple_elt&lt;
        T: Serialize&lt;Self, E&gt;
    &gt;(&amp;mut self, v: &amp;T) -&gt; Result&lt;(), E&gt;;
    fn serialize_tuple_end(&amp;mut self) -&gt; Result&lt;(), E&gt;;

    fn serialize_struct_start(&amp;mut self, name: &amp;str, len: uint) -&gt; Result&lt;(), E&gt;;
    fn serialize_struct_elt&lt;
        T: Serialize&lt;Self, E&gt;
    &gt;(&amp;mut self, name: &amp;str, v: &amp;T) -&gt; Result&lt;(), E&gt;;
    fn serialize_struct_end(&amp;mut self) -&gt; Result&lt;(), E&gt;;

    fn serialize_enum_start(&amp;mut self, name: &amp;str, variant: &amp;str, len: uint) -&gt; Result&lt;(), E&gt;;
    fn serialize_enum_elt&lt;
        T: Serialize&lt;Self, E&gt;
    &gt;(&amp;mut self, v: &amp;T) -&gt; Result&lt;(), E&gt;;
    fn serialize_enum_end(&amp;mut self) -&gt; Result&lt;(), E&gt;;

    fn serialize_option&lt;
        T: Serialize&lt;Self, E&gt;
    &gt;(&amp;mut self, v: &amp;Option&lt;T&gt;) -&gt; Result&lt;(), E&gt;;

    fn serialize_seq&lt;
        T: Serialize&lt;Self, E&gt;,
        Iter: Iterator&lt;T&gt;
    &gt;(&amp;mut self, iter: Iter) -&gt; Result&lt;(), E&gt;;

    fn serialize_map&lt;
        K: Serialize&lt;Self, E&gt;,
        V: Serialize&lt;Self, E&gt;,
        Iter: Iterator&lt;(K, V)&gt;
    &gt;(&amp;mut self, iter: Iter) -&gt; Result&lt;(), E&gt;;
}
</code></pre>

<p>There are many default methods, so only a handful of implementations need to be
specified. Now lets look at how they are used. Here&rsquo;s a simple
<code>AssertSerializer</code> that I use in my test suite to make sure I&rsquo;m serializing
properly:</p>

<pre><code class="rust">struct AssertSerializer&lt;Iter&gt; {
    iter: Iter,
}

impl&lt;'a, Iter: Iterator&lt;Token&lt;'a&gt;&gt;&gt; AssertSerializer&lt;Iter&gt; {
    fn new(iter: Iter) -&gt; AssertSerializer&lt;Iter&gt; {
        AssertSerializer {
            iter: iter,
        }
    }

    fn serialize&lt;'b&gt;(&amp;mut self, token: Token&lt;'b&gt;) -&gt; Result&lt;(), Error&gt; {
        let t = self.iter.next().unwrap();

        assert_eq!(t, token);

        Ok(())
    }
}

impl&lt;'a, Iter: Iterator&lt;Token&lt;'a&gt;&gt;&gt; Serializer&lt;Error&gt; for AssertSerializer&lt;Iter&gt; {
    fn serialize_null(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
        self.serialize(Token::Null)
    }
    fn serialize_bool(&amp;mut self, v: bool) -&gt; Result&lt;(), Error&gt; {
        self.serialize(Token::Bool(v))
    }
    fn serialize_int(&amp;mut self, v: int) -&gt; Result&lt;(), Error&gt; {
        self.serialize(Token::Int(v))
    }
    ...
}
</code></pre>

<p>Implementing <code>Serialize</code> for values follows the same pattern. Here&rsquo;s <code>bool</code>:</p>

<pre><code>impl&lt;S: Serializer&lt;E&gt;, E&gt; Serialize&lt;S, E&gt; for bool {
    #[inline]
    fn serialize(&amp;self, s: &amp;mut S) -&gt; Result&lt;(), E&gt; {
        s.serialize_bool(*self)
    }
}
</code></pre>

<p><code>Vec&lt;T&gt;</code>:</p>

<pre><code class="rust">impl&lt;
    S: Serializer&lt;E&gt;,
    E,
    T: Serialize&lt;S, E&gt;
&gt; Serialize&lt;S, E&gt; for Vec&lt;T&gt; {
    #[inline]
    fn serialize(&amp;self, s: &amp;mut S) -&gt; Result&lt;(), E&gt; {
        s.serialize_seq(self.iter())
    }
}

pub trait Serializer&lt;E&gt; {
    ...

    fn serialize_seq&lt;
        T: Serialize&lt;AssertSerializer&lt;Iter&gt;, Error&gt;,
        SeqIter: Iterator&lt;T&gt;
    &gt;(&amp;mut self, mut iter: SeqIter) -&gt; Result&lt;(), Error&gt; {
        let (len, _) = iter.size_hint();
        try!(self.serialize(Token::SeqStart(len)));
        for elt in iter {
            try!(elt.serialize(self));
        }
        self.serialize(Token::SeqEnd)
    }

    ...
}
</code></pre>

<p>And structs:</p>

<pre><code class="rust">struct Foo {
    a: (),
    b: uint,
    c: TreeMap&lt;String, Option&lt;char&gt;&gt;,
}

impl&lt;
  S: Serializer&lt;E&gt;,
  E
&gt; Serialize&lt;S, E&gt; for Foo {
    fn serialize(&amp;self, s: &amp;mut S) -&gt; Result&lt;(), E&gt; {
        try!(s.serialize_struct_start("Foo", 2u));
        try!(s.serialize_struct_elt("a", &amp;self.a));
        try!(s.serialize_struct_elt("b", &amp;self.b));
        try!(s.serialize_struct_elt("c", &amp;self.c));
        s.serialize_struct_end()
    }
}
</code></pre>

<p>Much simpler than deserialization.</p>

<h2>Performance</h2>

<p>So how does it perform? Here&rsquo;s the serialization benchmarks, with yet another
ordering. This time sorted by the performance:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library         </th>
<th> format                 </th>
<th> serialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> Rust     </td>
<td> capnproto-rust  </td>
<td> Cap&#8217;n Proto (unpacked) </td>
<td> 4349                 </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto    </td>
<td> Cap&#8217;n Proto            </td>
<td> 3824.20              </td>
</tr>
<tr>
<td> Rust     </td>
<td> bincode         </td>
<td> Binary                 </td>
<td> 1020                 </td>
</tr>
<tr>
<td> Go       </td>
<td> gogoprotobuf    </td>
<td> Protocol Buffers       </td>
<td> 596.78               </td>
</tr>
<tr>
<td> Rust     </td>
<td> capnproto-rust  </td>
<td> Cap&#8217;n Proto (packed)   </td>
<td> 583                  </td>
</tr>
<tr>
<td> Rust     </td>
<td> rust-msgpack    </td>
<td> MessagePack            </td>
<td> 397                  </td>
</tr>
<tr>
<td> Rust     </td>
<td> rust-protobuf   </td>
<td> Protocol Buffers       </td>
<td> 357                  </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson       </td>
<td> JSON                   </td>
<td> 304                  </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serde::json</strong> </td>
<td> <strong>JSON</strong>               </td>
<td> <strong>222</strong>              </td>
</tr>
<tr>
<td> Go       </td>
<td> goprotobuf      </td>
<td> Protocol Buffers       </td>
<td> 214.68               </td>
</tr>
<tr>
<td> Go       </td>
<td> ffjson          </td>
<td> JSON                   </td>
<td> 147.37               </td>
</tr>
<tr>
<td> Rust     </td>
<td> serialize::json </td>
<td> JSON                   </td>
<td> 147                  </td>
</tr>
<tr>
<td> Go       </td>
<td> encoding/json   </td>
<td> JSON                   </td>
<td> 80.49                </td>
</tr>
</tbody>
</table>


<p><code>serde::json</code> is doing pretty good! It still has got a ways to go to catch up
to <a href="https://github.com/miloyip/rapidjson">rapidjson</a>, but it&rsquo;s pretty cool it&rsquo;s
beating <a href="https://github.com/golang/protobuf">goprotobuf</a> out of the box :)</p>

<p>Here are the deserialization numbers:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library         </th>
<th> format                  </th>
<th> deserialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> Rust     </td>
<td> capnproto-rust  </td>
<td> Cap&#8217;n Proto (unpacked)  </td>
<td> 2185                   </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto    </td>
<td> Cap&#8217;n Proto (zero copy) </td>
<td> 1407.95                </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto    </td>
<td> Cap&#8217;n Proto             </td>
<td> 711.77                 </td>
</tr>
<tr>
<td> Rust     </td>
<td> capnproto-rust  </td>
<td> Cap&#8217;n Proto (packed)    </td>
<td> 351                    </td>
</tr>
<tr>
<td> Go       </td>
<td> gogoprotobuf    </td>
<td> Protocol Buffers        </td>
<td> 272.68                 </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson       </td>
<td> JSON (sax)              </td>
<td> 189                    </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson       </td>
<td> JSON (dom)              </td>
<td> 162                    </td>
</tr>
<tr>
<td> Rust     </td>
<td> rust-msgpack    </td>
<td> MessagePack             </td>
<td> 138                    </td>
</tr>
<tr>
<td> Rust     </td>
<td> rust-protobuf   </td>
<td> Protocol Buffers        </td>
<td> 129                    </td>
</tr>
<tr>
<td> Go       </td>
<td> ffjson          </td>
<td> JSON                    </td>
<td> 95.06                  </td>
</tr>
<tr>
<td> Rust     </td>
<td> bincode         </td>
<td> Binary                  </td>
<td> 80                     </td>
</tr>
<tr>
<td> Go       </td>
<td> goprotobuf      </td>
<td> Protocol Buffers        </td>
<td> 79.78                  </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serde::json</strong> </td>
<td> <strong>JSON</strong>                </td>
<td> <strong>67</strong>                 </td>
</tr>
<tr>
<td> Rust     </td>
<td> serialize::json </td>
<td> JSON                    </td>
<td> 24                     </td>
</tr>
<tr>
<td> Go       </td>
<td> encoding/json   </td>
<td> JSON                    </td>
<td> 22.79                  </td>
</tr>
</tbody>
</table>


<p>Well on the plus side, <code>serde::json</code> nearly 3 times faster than
<code>libserialize::json</code>. On the downside rapidjson is nearly 3 times faster than
us in it&rsquo;s SAX style parsing. Even the newly added deserialization support in
<a href="https://github.com/pquerna/ffjson">ffjson</a> is 1.4 times faster than us. So we
got more work cut out for us!</p>

<p>Next time, serde2!</p>

<p>PS: I&rsquo;m definitely getting close to the end of my story, and while I have some
better numbers with serde2, nothing is quite putting me in the rapidjson
range. Anyone want to help optimize
<a href="https://github.com/erickt/rust-serde">serde</a>? I would greatly appreciate the help!</p>

<p>PPS: I&rsquo;ve gotten a number of requests for my
<a href="https://github.com/erickt/rust-serialization-benchmarks">serialization benchmarks</a>
to be ported over to other languages and libraries. Especially a C++ version
of Cap&#8217;n Proto. Unfortunately I don&rsquo;t really have the time to do it myself.
Would anyone be up for helping to implement it?</p>

<p>comments on <a href="https://www.reddit.com/r/rust/comments/2p85za/rewriting_rust_serialization_part_3_introducing/">reddit</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rewriting Rust Serialization, Part 2.2: More Benchmarks]]></title>
    <link href="http://erickt.github.io/blog/2014/11/13/benchmarks-2/"/>
    <updated>2014-11-13T09:07:36-08:00</updated>
    <id>http://erickt.github.io/blog/2014/11/13/benchmarks-2</id>
    <content type="html"><![CDATA[<p>Back to the benchmarks! I got some great comments on
<a href="https://www.reddit.com/r/rust/comments/2lzc9n/rust_serialization_part_21_now_with_more/">reddit</a>,
So I wanted to do another post to update my numbers. Here&rsquo;s what I changed:</p>

<ul>
<li>I wasn&rsquo;t consistent on whether or not the serialization benchmarks included
Some tests are including the allocation of a buffer to write into. I&rsquo;ve
  changed it so most are reusing one, which speeds everything up (especially
capnproto-rust!). This does depend on
<a href="https://github.com/rust-lang/rust/pull/18885">#18885</a> landing though.</li>
<li>I&rsquo;ve added <a href="https://github.com/TyOverby/bincode">bincode</a>, which serializes
values as raw bytes. Quite speedy too! Not nearly as fast as Cap&#8217;n Proto though.</li>
<li>I&rsquo;ve changed <code>C++</code> and <code>Rust</code> JSON tests to serialize enums as uints.</li>
<li>I added the time it takes to create the populate the structures. I&rsquo;m betting
  the reason the Rust numbers are so high is that we&rsquo;re allocating strings. Not
sure if the other languages are able to avoid that allocation.</li>
</ul>


<hr />

<p>JSON:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library         </th>
<th> population (ns) </th>
<th> serialization (MB/s) </th>
<th> deserialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> Rust     </td>
<td> serialize::json </td>
<td> 1127            </td>
<td> 117                  </td>
<td> 26                     </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson (dom) </td>
<td> 546             </td>
<td> 281                  </td>
<td> 144                    </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson (dom) </td>
<td> 546             </td>
<td> 281                  </td>
<td> 181                    </td>
</tr>
<tr>
<td> Go       </td>
<td> encoding/json   </td>
<td> 343             </td>
<td> 63.99                </td>
<td> 22.46                  </td>
</tr>
<tr>
<td> Go       </td>
<td> ffjson          </td>
<td> 343             </td>
<td> 144.60               </td>
<td> (not supported)        </td>
</tr>
</tbody>
</table>


<hr />

<p>Cap&#8217;n Proto:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library                   </th>
<th> population (ns) </th>
<th> serialization (MB/s) </th>
<th> deserialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> Rust     </td>
<td> capnproto-rust (unpacked) </td>
<td> 325             </td>
<td> 4977                 </td>
<td> 2251                   </td>
</tr>
<tr>
<td> Rust     </td>
<td> capnproto-rust (packed)   </td>
<td> 325             </td>
<td> 398                  </td>
<td> 246                    </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto              </td>
<td> 2368            </td>
<td> 2226.71              </td>
<td> 450                    </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto (zero copy)  </td>
<td> 2368            </td>
<td> 2226.71              </td>
<td> 1393.3                 </td>
</tr>
</tbody>
</table>


<hr />

<p>Protocol Buffers:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library       </th>
<th> population (ns) </th>
<th> serialization (MB/s) </th>
<th> deserialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> Rust     </td>
<td> rust-protobuf </td>
<td> 1041            </td>
<td> 370                  </td>
<td> 118                    </td>
</tr>
<tr>
<td> Go       </td>
<td> goprotobuf    </td>
<td> 1133            </td>
<td> 138.27               </td>
<td> 91.18                  </td>
</tr>
<tr>
<td> Go       </td>
<td> gogoprotobuf  </td>
<td> 343             </td>
<td> 472.69               </td>
<td> 295.33                 </td>
</tr>
</tbody>
</table>


<hr />

<p>Misc:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library      </th>
<th> population (ns) </th>
<th> serialization (MB/s) </th>
<th> deserialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> Rust     </td>
<td> rust-msgpack </td>
<td> 1143            </td>
<td> 454                  </td>
<td> 144                    </td>
</tr>
<tr>
<td> Rust     </td>
<td> bincode      </td>
<td> 1143            </td>
<td> 1149                 </td>
<td> 82                     </td>
</tr>
</tbody>
</table>


<p>Anyone want to add more C/Go/Rust/Java/etc benchmarks?</p>
]]></content>
  </entry>
  
</feed>
