<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rust | Chasing Rabbits]]></title>
  <link href="http://erickt.github.io/blog/categories/rust/atom.xml" rel="self"/>
  <link href="http://erickt.github.io/"/>
  <updated>2016-02-27T07:43:59-08:00</updated>
  <id>http://erickt.github.io/</id>
  <author>
    <name><![CDATA[Erick Tryzelaar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Serde 0.7]]></title>
    <link href="http://erickt.github.io/blog/2016/02/26/serde-0-dot-7/"/>
    <updated>2016-02-26T23:06:11-08:00</updated>
    <id>http://erickt.github.io/blog/2016/02/26/serde-0-dot-7</id>
    <content type="html"><![CDATA[<p>I&rsquo;m thrilled to announce <a href="https://github.com/serde-rs/serde">Serde</a> 0.7.0!
It&rsquo;s been a long time coming, and has a number of long awaited new features,
breaking changes, and other notable changes.  Serde 0.6.x is now deprecated,
and while I&rsquo;ll try to keep <code>serde_codegen</code> and <code>serde_macros</code> while projects
switch over to 0.7, I&rsquo;m going to shift more to a pull-based approach, so please
file a bug ticket if a nightly release has broken you.</p>

<p>On to the list on the major changes!</p>

<h2>Serde</h2>

<ul>
<li>Removed the word <code>Error</code> from <code>serde::de::Error</code> variants.</li>
<li>Renamed <code>visit_</code> methods to <code>serialize_</code> and <code>deserialize_</code>.</li>
<li>Removed dependency on the deprecated <a href="https://github.com/rust-num/num">num</a>
crate.</li>
<li>Require that implementations of <code>serde::de::Error</code> implement
<code>std::error::Error</code>.</li>
<li>Added <code>serde::de::Deserializer::deserialize_struct_field</code> hook that allows a
<code>Deserializer</code> to know the next value is a struct field.</li>
<li>Added <code>serde::ser::Error</code>, which allows a <code>Serialize</code> type produce an error
if it cannot be serialized.</li>
<li>Serializing <code>std::path::Path</code> with non-unicode characters will result in a
Serde error, rather than a panic.</li>
<li>Added implementations for <code>std::net</code> types.</li>
<li>Added <code>serde::de::Error::unknown_variant</code> error message hook.</li>
<li>Renamed <code>serde::de::Error::syntax</code> to <code>serde::de::Error::custom</code>.</li>
</ul>


<h2>Serde Codegen and Macros</h2>

<ul>
<li>Serde now by default ignores unknown fields when deserializing.  The previous
behavior, where Serde will report unknown fields as an error, can be
  opted in with the container annotation <code>#[serde(deny_unknown_fields)]</code>,
as in:</li>
</ul>


<pre><code class="rust">#[serde(deny_unknown_fields)]
struct Point {
    x: usize,
    y: usize,
}
</code></pre>

<ul>
<li>Added the container annotation <code>#[serde(rename="...")]</code>to rename the
container, as in:</li>
</ul>


<pre><code class="rust">#[serde(rename="point")]
struct Point {
    x: usize,
    y: usize,
}
</code></pre>

<ul>
<li>Added the variantl annotation <code>#[serde(rename="...")]</code> to rename
variants, as in:</li>
</ul>


<pre><code class="rust">enum Value {
    #[serde(rename="type")]
    Type
}
</code></pre>

<ul>
<li>Added rename annotation <code>#[serde(rename(serialize="...", deserialize="..."))]</code>
  that supports crazy schemas like AWS that expect serialized fields with the
first character lower case, and the deserialized response with the first
character upper cased.</li>
<li>Removed support for the unused format-specific rename support.</li>
<li>Added the field annotation <code>#[serde(default="$path")]</code>, where <code>$path</code> is a
reference to some function that returns a default value for a field if it&rsquo;s
not present when deserializing.  For example:</li>
</ul>


<pre><code class="rust">trait MyDefault {
    fn my_default() -&gt; Self;
}

struct Point&lt;T: MyDefault&gt; {
    x: T,
    #[serde(default="MyDefault::my_default")]
    y: T,
}
</code></pre>

<ul>
<li>Added the field annotation <code>#[serde(skip_serializing_if="$path")]</code>, where
<code>$path</code> is a path reference to some function that returns a <code>bool</code>, that if
true, should skip serializing the field.</li>
</ul>


<pre><code class="rust">trait ShouldSkip {
    fn should_skip(&amp;self) -&gt; bool;
}

struct Point&lt;T: ShouldSkip&gt; {
    x: T,
    #[serde(skip_serializing_if="ShouldSkip::should_skip")]
    y: T,
}
</code></pre>

<ul>
<li>Added the field annotations <code>#[serde(serialize_with="$path")]</code> and
<code>#[serde(deserialize_with="$path")]</code>, where <code>$path</code> us a path reference to
some function that serializes a field, as in:</li>
</ul>


<pre><code class="rust">trait MySerialization {
    fn serialize_with&lt;S: Serializer&gt;(&amp;self, serializer: &amp;mut S) -&gt; Result&lt;(), S::Error&gt;;

    fn deserialize_with&lt;D: Deserializer&gt;(deserializer: &amp;mut D) -&gt; Result&lt;Self, D::Error&gt;;
}

struct Record {
    #[serde(serialize_with="MySerialization::serialize_with")]
    #[serde(deserialize_with="MySerialization::deserialize_with")]
    timestamp: time::Timespec,
}
</code></pre>

<h2>Serde JSON</h2>

<ul>
<li>Added <code>StreamDeserializer</code>, that enables parsing a stream of JSON values optionally
separated by whitespace into an iterator of those deserialized values.</li>
</ul>


<h2>Thanks</h2>

<p>I&rsquo;d like to thank everyone that&rsquo;s helped out over the past few months. Please
forgive me if I accidentally left you off the list:</p>

<ul>
<li>Craig M. Brandenburg</li>
<li>Florian Gilcher</li>
<li>Hans Kristian Flaatten</li>
<li>Issam Hakimi</li>
<li>Joe Wilm</li>
<li>John Heitmann</li>
<li>Marek Kotewicz</li>
<li>Ms2ger</li>
<li>Nathan Lilienthal</li>
<li>Oliver Schneider</li>
<li>Paul Woolcock</li>
<li>Roma Sokolov</li>
<li>Simon Persson</li>
<li>Thomas Bahn</li>
<li>Tom Jakubowski</li>
<li>thorbenk</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stateful, Part 2: How Stateful Cheats at Analysis]]></title>
    <link href="http://erickt.github.io/blog/2016/01/28/stateful/"/>
    <updated>2016-01-28T08:22:33-08:00</updated>
    <id>http://erickt.github.io/blog/2016/01/28/stateful</id>
    <content type="html"><![CDATA[<p>As I mentioned in the last
<a href="https://erickt.github.io/blog/2016/01/27/stateful-in-progress-generators/">part</a>,
<code>Stateful</code> has some challenges it needs to overcome in order to add new and
exciting control flow mechanisms to Rust.  While we don&rsquo;t get access to any of
the cool analysis passes inside the Rust compiler, <code>Stateful</code> is able to sneak
around their necessity in many cases since it really only needs to support a
subset of Rust.  Here are some of the techniques it exploits, err, uses.</p>

<h3>Variables</h3>

<p>First off, let&rsquo;s talk about variables.  One of the primary things <code>Stateful</code>
needs to do is manage the process of state flowing through the machine.  However,
consider a statement like this:</p>

<pre><code class="rust">let x = ...;
</code></pre>

<p>&ldquo;Obviously it&rsquo;s a variable, right?&rdquo;  Actually you can&rsquo;t be sure.  What if
someone did:</p>

<pre><code class="rust">enum Foo {
    x,
}
use Foo::*;
</code></pre>

<p>Well then the compiler would helpfully report:</p>

<pre><code>foo.rs:7:9: 7:10 error: declaration of `x` shadows an enum variant or unit-like struct in scope [E0413]
foo.rs:7     let x = x;
</code></pre>

<p>But that warning only works for simple <code>let</code> statements.  Consider what happens
with matches.  Consider:</p>

<pre><code class="rust">match ... {
    x =&gt; { ... }
    y =&gt; { ... }
}
</code></pre>

<p>Is <code>x</code> or <code>y</code> a variable, or a variant?  There&rsquo;s no way to know unless you
perform name resolution, otherwise known as the resolve pass in the compiler.
Unfortunately though, there&rsquo;s no way for <code>Stateful</code> to run that analysis.  As
Sm√©agol said, &ldquo;There is another way.  More secret, and dark way.&rdquo;.  This leads
us to Cheat Number One: <strong>Stateful assumes that all lowercase identifiers are
variables, and uppercase ones are enum variants.</strong> Sure, Rust supports
lowercase variants, but there&rsquo;s no reason why <code>Stateful</code> has to use them.  It
makes our lives much easier.</p>

<h3>Types</h3>

<p>The next problem is typing.  Sure, Rust is nice and all that you can write a
local variable like <code>let x = ...</code> and it&rsquo;ll infer the type for you.  All Rust
asks for is that the user explicitly specify the type of a value that enters or
leaves the bounds of a function.  Our problem is that one of the main tasks of
<code>Stateful</code> is to lift variables into some <code>State</code> structure so that their
available when the function is re-entered.  So in effect, all variables inside
<code>Stateful</code> must be typed.  Consider the example from last week:</p>

<pre><code class="rust">fn advance(mut state: State) -&gt; (Option&lt;usize&gt;, State) {
    loop {
        match state {
            State::Enter =&gt; {
                let mut i = 0;
                goto!(State::Loop { i: i });
            }
            State::Loop { mut i } =&gt; {
                if i &lt; 3 {
                    goto!(State::Then { i: i });
                } else {
                    goto!(State::Else { i: i });
                }
            }
            State::Then { mut i } =&gt; {
                return_!(Some(i); State::AfterYield { i: i });
            }
            State::Else { mut i } =&gt; {
                goto!(State::AfterLoop { i: i });
            }
            State::AfterYield { mut i } =&gt; {
                i += 1;
                goto!(State::Loop { i: i });
            }
            State::AfterLoop { mut i } =&gt; {
                goto!(State::Exit);
            }
            State::Exit =&gt; {
                return_!(None; State::Exit);
            }
        }
    }
}
</code></pre>

<p>This <code>State</code> enumeration is what I&rsquo;m talking about.  It gets passed into and
out of the <code>advance</code> function.  It needs to be some concrete type, which looks
something like this:</p>

<pre><code class="rust">enum State {
    Enter,
    Loop { i: usize },
    Then { i: usize },
    Else { i: usize },
    AfterYield { i: usize },
    AfterLoop { i: usize },
    Exit,
}
</code></pre>

<p>The problem is that we want to write code like this:</p>

<pre><code class="rust">#[generator]
fn gen3() -&gt; Iterator&lt;Item=usize&gt; {
    let mut i = 0;
    while i &lt; 3 {
        yield_!(i);
        i += 1;
    }
}
</code></pre>

<p>So how can we resolve this?  Well first, we could wait for
<a href="https://github.com/rust-lang/rfcs/pull/105">RFC 105</a>
or <a href="https://github.com/rust-lang/rfcs/pull/1305">RFC 1305</a> to get implemented,
but that&rsquo;s not happening any time soon.  Until then, there is cheat number two:
<strong>Hide state variables in a boxed trait</strong>.  This one is from Eduard Burtescu.
Instead of the nice well typed example from the last post, we actually generate
some code that hides the types with an over abundance of generic types:</p>

<pre><code class="rust">fn gen3() -&gt; Iterator&lt;Item=usize&gt; {
    struct Wrapper&lt;S, F&gt; {
        state: S,
        next: F,
    }

    impl&lt;S, T, F&gt; Iterator for Wrapper&lt;S, F&gt;
        where S: Default,
              F: Fn(S) -&gt; (Option&lt;T&gt;, S)
      {
          type Item = T;

          fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
              let old_state = ::std::mem::replace(
                  &amp;mut self.state,
                  S::default());

              let (value, next_state) = (self.next)(old_state);
              self.state = next_state;
              value
          }
      }

    enum State&lt;T0&gt; {
        Enter,
        Loop { i: T0 },
        Then { i: T0 },
        Else { i: T0 },
        AfterYield { i: T0 },
        AfterLoop { i: T0 },
        Exit,
    }

    impl&lt;T0&gt; Default for State&lt;T0&gt; {
        fn default() -&gt; Self {
            {
                State::State1End
            }
        }
    }

    Box::new(Wrapper::new(State::Start, |mut state| {
        loop {
            match state {
                State::Enter =&gt; {
                    let mut i = 0;
                    goto!(State::Loop { i: i });
                }
                State::Loop { mut i } =&gt; {
                    if i &lt; 3 {
                        goto!(State::Then { i: i });
                    } else {
                        goto!(State::Else { i: i });
                    }
                }
                State::Then { mut i } =&gt; {
                    return_!(Some(i); State::AfterYield { i: i });
                }
                State::Else { mut i } =&gt; {
                    goto!(State::AfterLoop { i: i });
                }
                State::AfterYield { mut i } =&gt; {
                    i += 1;
                    goto!(State::Loop { i: i });
                }
                State::AfterLoop { mut i } =&gt; {
                    goto!(State::Exit);
                }
                State::Exit =&gt; {
                    return_!(None; State::Exit);
                }
            }
        }
    }))
}
</code></pre>

<p>All for the cost of a boxed variable.  It&rsquo;s not ideal, but it does let us keep
experimenting.  However, if we do want to avoid this allocation, we can just
require that all variables that survive across a yield point have their type
specified.  So our previous example would be written as:</p>

<pre><code class="rust">#[generator]
fn gen3() -&gt; Iterator&lt;Item=usize&gt; {
    let mut i: usize = 0;
    while i &lt; 3 {
        yield_!(i);
        i += 1;
    }
}
</code></pre>

<p>It&rsquo;s not so bad here, but it&rsquo;d get obnoxious if we had a generator like:</p>

<pre><code class="rust">#[generator]
fn complicated(items: &amp;[usize]) -&gt; Iterator&lt;Item=usize&gt; {
    let iter = items.iter().map(|item| item * 3);

    for item in iter {
        yield_!(item);
    }
}
</code></pre>

<p>The type of <code>iter</code>, by the way, is impossible to write because there is
currently no way to specify the type of the closure.  Instead, it needs to be
rewritten to use a free function:</p>

<pre><code class="rust">#[generator]
fn complicated(items: &amp;[usize]) -&gt; Iterator&lt;Item=usize&gt; {
    fn map&lt;'a&gt;(item: &amp;'a usize) -&gt; usize { *item * 3 }

    let iter: std::iter::Map&lt;
            std::slice::Iter&lt;'a, usize&gt;,
            fn(&amp;'a usize) -&gt; usize
        &gt;
        = items.iter().map(map);

    for item in iter {
        yield_!(item);
    }
}
</code></pre>

<p>If we want to support closures though, we need to use the <code>Box&lt;Iterator&lt;...&gt;</code>
trick.</p>

<h3>References</h3>

<p>This one&rsquo;s a doozy.  Here&rsquo;s an example of the problem.  Consider:</p>

<pre><code class="rust">#[generator]
fn gen&lt;'a&gt;(opt: Option&lt;&amp;'a mut usize&gt;) -&gt; Iterator&lt;Item=&amp;'a mut usize&gt; {
    match opt {
        Some(value) =&gt; { yield_!(value); }
        None =&gt; { }
    }
}
</code></pre>

<p>This would look something like this (which also demonstrates how <code>match</code>
statements are represented):</p>

<pre><code class="rust">...
Box::new(Wrapper::new(State::State0Start { opt: opt }, |mut state| {
    loop {
        match state {
            State::State0Start { opt: opt } =&gt; {
                match opt {
                    Some(value) =&gt; {
                        state = State::State2Arm {
                            opt: opt,
                            value: value,
                        };
                        continue;
                    }
                    None =&gt; {
                        state = State::State3Arm { opt: opt };
                        continue;
                    }
                }
            }
            State::State1End =&gt; {
                return (::std::option::Option::None, State::State1End);
            }
            State::State2Arm { opt: opt, value: value } =&gt; {
                return (::std::option::Option::Some(value),
                        State::State5AfterYield {
                    opt: opt,
                    value: value,
                });
            }
            State::State3Arm { opt: opt } =&gt; {
                {
                };
                state = State::State4MatchJoin { opt: opt };
                continue;
            }
            State::State4MatchJoin { opt: opt } =&gt; {
                ::std::mem::drop(opt);
                state = State::State1End;
                continue;
            }
            State::State5AfterYield {
                              opt: opt, value: value } =&gt; {
                ::std::mem::drop(value);
                state = State::State4MatchJoin { opt: opt };
                continue;
            }
        }
    }
}))
</code></pre>

<p>Zero in on this block:</p>

<pre><code class="rust">...
Some(value) =&gt; {
    state = State::State2Arm {
        opt: opt,
        value: value,
    };
    continue;
}
...
</code></pre>

<p>The type of <code>opt</code> is <code>Option&lt;&amp;'a mut usize&gt;</code>, and <code>value</code> is <code>&amp;'a mut usize</code>.
So we&rsquo;ve got two outstanding mutable borrows, which is illegal.  The real
problem is that <code>Stateful</code> without Resolve and the Borrow Checker pass, it
cannot know if a use of the variable is a copy or move in all cases.  So we now
have cheat number 3: <strong>Use pseudo-macros to hint to Stateful if a type is
copyable or movable</strong>.  This is the same technique we use to implement the
pseudo-macro <code>yield_!(...)</code>, where we would add <code>move_!(...)</code> and <code>copy_!(...)</code>
to inform <code>Stateful</code> when something has been, well, moved or copied.  Our
previous example would then be written as:</p>

<pre><code class="rust">#[generator]
fn gen&lt;'a&gt;(opt: Option&lt;&amp;'a mut usize&gt;) -&gt; Iterator&lt;Item=&amp;'a mut usize&gt; {
    match move_!(opt) {
        Some(value) =&gt; { yield_!(value); }
        None =&gt; { }
    }
}
</code></pre>

<p>Which would then give <code>Stateful</code> enough information to generate something like
this, which would then know that the match consumed the option:</p>

<pre><code class="rust">Box::new(Wrapper::new(State::State0Start { opt: opt }, |mut state| {
    loop {
        match state {
            State::State0Start { opt: opt } =&gt; {
                match opt {
                    Some(value) =&gt; {
                        state = State::State2Arm {
                            value: value,
                        };
                        continue;
                    }
                    None =&gt; {
                        state = State::State3Arm;
                        continue;
                    }
                }
            }
            State::State1End =&gt; {
                return (::std::option::Option::None, State::State1End);
            }
            State::State2Arm { value: value } =&gt; {
                return (::std::option::Option::Some(value),
                State::State5AfterYield);
            }
            State::State3Arm =&gt; {
                state = State::State4MatchJoin;
                continue;
            }
            State::State4MatchJoin =&gt; {
                state = State::State1End;
                continue;
            }
            State::State5AfterYield =&gt; {
                state = State::State4MatchJoin;
                continue;
            }
        }
    }
}))
</code></pre>

<p>I&rsquo;m also considering some default rules, that can be overridden with these
macros:</p>

<ul>
<li>If a value is known to be copyable (it&rsquo;s a primitive type, or it&rsquo;s a <code>&amp;T</code>
type), then it&rsquo;s always copied. All other types are assumed to not be
copyable.</li>
<li>Non-copyable types are moved when passed into a function argument, unless
wrapped in a <code>copy_!(...)</code> hint.</li>
<li>Non-copyable type method calls are by reference, unless explicitly wrapped in
a <code>move_!(...)</code> hint.</li>
<li>Non-copyable types are moved in <code>match</code> statement, unless one of the match
arms uses <code>ref</code> or <code>ref mut</code>.</li>
</ul>


<p>Hopefully this will enable a vast majority of code to work without
<code>copy_!(...)</code> or <code>move_!(...)</code>.</p>

<h3>Conclusion</h3>

<p>Those are our major cheats!  I&rsquo;m sure there will be plenty more in the future.
In the meantime, I want to show off some some actual working code!  Check this
puppy out!</p>

<pre><code class="rust">#![feature(plugin)]
#![plugin(stateful)]

#![allow(dead_code)]
#![allow(non_shorthand_field_patterns)]
#![allow(unused_mut)]
#![allow(unused_variables)]

#[generator]
fn gen&lt;'a, T&gt;(items: &amp;'a [T]) -&gt; &amp;'a T {
    let mut iter = items.iter();
    loop {
        match iter.next() {
            Some(item) =&gt; {
                yield_!(item);
            }
            None =&gt; {
                break;
            }
        };
    };
}

fn main() {
    let items = &amp;[1, 2, 3];
    for value in gen(items).take(20) {
        println!("{}", value);
    }
}
</code></pre>

<p>Produces:</p>

<pre><code>1
2
3
</code></pre>

<p>Isn&rsquo;t it beautiful?  We got generics, mutable variables, loops, matches,
breaks, <strong>and</strong> a whole host of ignored warnings!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stateful: A Rust Experimental Syntax Extension for Generators and More]]></title>
    <link href="http://erickt.github.io/blog/2016/01/27/stateful-in-progress-generators/"/>
    <updated>2016-01-27T08:31:27-08:00</updated>
    <id>http://erickt.github.io/blog/2016/01/27/stateful-in-progress-generators</id>
    <content type="html"><![CDATA[<p>AKA: Erick Does More Horrible Things to Rust</p>

<p>Hello internet! It&rsquo;s been too long. Not only are the
<a href="http://www.meetup.com/rust-bay-area">Rust Meetups</a> back up and running, it&rsquo;s
time for me to start back to blogging. For the past couple months, I&rsquo;ve been
working on a new syntax extension that will allow people to create fun and
exciting new control flow mechanisms in stable Rust.  &ldquo;For the love of all that
is sigils, why?!&rdquo;  Well, Because I can.  Sometimes when you stare into the
madness, it stares back into you? Or something like that?</p>

<p>It&rsquo;s called <a href="https://github.com/erickt/stateful">Stateful</a>, which helpfully has
no documentation. Such an innocent name, right?  It&rsquo;s very much in progress
(and mostly broken) implementation of some of the ideas in this and future
posts.  So don&rsquo;t go and think these code snippets are executable just yet :)</p>

<p>Anyway, lets show off <code>Stateful</code> by showing how we can implement
<a href="https://en.wikipedia.org/wiki/Generator_%28computer_programming%29">Generators</a>.
We&rsquo;ve got an <a href="https://github.com/rust-lang/rfcs/issues/388">RFC ticket</a> to
implement them, but wouldn&rsquo;t it be nice to have them sooner?  For those of you
unfamiliar with the concept, Generators are function that can be returned from
multiple times, all while preserving state between those calls.  Basically,
they&rsquo;re just a simpler way to write
<a href="https://doc.rust-lang.org/std/iter/#iterator">Iterators</a>.</p>

<p>Say we wanted to iterate over the numbers 0, 1, and 2.  Today, we would write
an <code>Iterator</code> with something like this:</p>

<pre><code class="rust">struct Iter3(usize);

impl Iter3 {
    fn new() -&gt; Self {
        Iter3(0)
    }
}

impl Iterator for Iter3 {
    fn next(&amp;mut self) -&gt; Option&lt;usize&gt; {
        if self.0 &lt; 3 {
            let i = self.0;
            self.0 += 1;
            Some(i)
        } else {
            None
        }
    }
}

fn main() {
    let iter = Iter3::new();
    assert_eq!(iter.next(), Some(0));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), None);
}
</code></pre>

<p>The struct preserves our state across these function calls.  It&rsquo;s a pretty
straightforward implementation, but it does have some amount of boilerplate
code. For large iterator implementations, this state management can get quite
complicated.  Instead, lets see how this same code could be expressed with
something like <code>Stateful</code>:</p>

<pre><code class="rust">#![plugin(stateful)]

#[generator]
fn gen3() -&gt; Iterator&lt;Item=usize&gt; {
    let mut i = 0;
    while i &lt; 3 {
        yield_!(i);
        i += 1;
    }
}
</code></pre>

<p>Where <code>yield_!(i)</code> is some magical control flow mechanism that not only
returned some value <code>Some(i)</code>, but also made sure on the <code>iter.next()</code> would
jump the execution to just after the yield.  At the end of the generator, we&rsquo;d
just return <code>None</code>.  We could simplify this even more by unrolling that loop
into:</p>

<pre><code class="rust">#[generator]
fn gen3_unrolled() -&gt; Iterator&lt;Item=usize&gt; {
    yield_!(0);
    yield_!(1);
    yield_!(2);
}
</code></pre>

<p>The fun part is figuring out how to convert these generators into something
that&rsquo;s roughly equivalent to <code>Iter3</code>.  At it&rsquo;s heart, <code>Iter3</code> really is a
simple state machine, where we save the counter state in the structure before
we &ldquo;yield&rdquo; the value to the caller.  Let&rsquo;s look at what we would generate for
<code>gen3_unrolled</code>.</p>

<p>First, we need some boilerplate, that sets up the state of our generator.  We
don&rsquo;t yet have <a href="https://aturon.github.io/blog/2015/09/28/impl-trait/">impl
trait</a>, so we hide all
our stuff in a module:</p>

<pre><code class="rust">fn gen3_unrolled() -&gt; gen3_unrolled::Generator {
    gen3_unrolled::Generator::new()
}

mod gen3_unrolled {
    pub struct Generator {
        state: State,
    }

    impl Generator {
        pub fn new() -&gt; Self {
            Generator {
                state: State::Enter,
            }
        }
    }

    ...
</code></pre>

<p>We represent our generator&rsquo;s state with an enum.  We have our initial state, a
state per yield, then an exit state:</p>

<pre><code class="rust">    enum State {
        Enter,
        AfterYield0,
        AfterYield1,
        AfterYield2,
        Exit,
    }
</code></pre>

<p>Finally, we have our state machine, and a pretty trivial <code>Iterator</code>
implementation that manages entering and exiting the state machine:</p>

<pre><code class="rust">    impl Iterator for Generator {
        type Item = usize;

        fn next(&amp;mut self) -&gt; Option&lt;usize&gt; {
            let state = mem::replace(&amp;mut self.state, State::Exit);
            let (result, next_state) = advance(state);
            self.state = next_state;
            result
        }
    }

    fn advance(mut state: State) -&gt; (Option&lt;usize&gt;, State) {
        loop {
            state = match state {
                State::Enter =&gt; {
                    return_!(Some(0); State::AfterYield0);
                }
                State::AfterYield0 =&gt; {
                    return_!(Some(1); State::AfterYield1);
                }
                State::AfterYield1 =&gt; {
                    return_!(Some(2); State::AfterYield2);
                }
                State::AfterYield2 =&gt; {
                    goto!(State::Exit);
                }
                State::Exit =&gt; {
                    return_!(None; State::Exit);
                }
            }
        }
    }
}
</code></pre>

<p>We move the current <code>state</code> into <code>advance</code>, then have this <code>loop-match</code> state
machine.  Then there are 2 new control flow constructs:
<code>return_!($expr; $next_state)</code> and our old friend <code>goto!($next_state)</code>.
<code>return_!()</code> returns some value and also sets the position the generator should
resume at, and <code>goto!()</code> just sets the next state without leaving the function.</p>

<p>Here&rsquo;s one way they might be implemented:</p>

<pre><code class="rust">macro_rules! goto {
    ($next_state:expr) =&gt; {
        $state = $next_state;
        continue;
    }
}

macro_rules! return_ {
    ($result: expr; $next_state:expr) =&gt; {
        return ($result, $next_state);
    }
}
</code></pre>

<p>Relatively straightforward transformation, right?  But that&rsquo;s an easy case.
Things start to get a wee bit more complicated when we start thinking about how
we&rsquo;d transform <code>gen3</code>, because it&rsquo;s got both a <code>while</code> loop and a mutable
variable.  Lets see that in action.  I&rsquo;ll leave out the boilerplate code and
just focus on the <code>advance</code> function:</p>

<pre><code class="rust">fn advance(mut state: State) -&gt; (Option&lt;usize&gt;, State) {
    loop {
        match state {
            State::Enter =&gt; {
                let mut i = 0;
                goto!(State::Loop(i));
            }
            State::Loop(mut i) =&gt; {
                if i &lt; 3 {
                    goto!(State::Then(i));
                } else {
                    goto!(State::Else(i));
                }
            }
            State::Then(mut i) =&gt; {
                return_!(Some(i); State::AfterYield(i));
            }
            State::Else(mut i) =&gt; {
                goto!(State::AfterLoop(i));
            }
            State::AfterYield(mut i) =&gt; {
                i += 1;
                goto!(State::Loop(i));
            }
            State::AfterLoop(mut i) =&gt; {
                goto!(State::Exit);
            }
            State::Exit =&gt; {
                return_!(None; State::Exit);
            }
        }
    }
}
</code></pre>

<p>Now things are getting interesting! There are two critical things we can see
off the bat.  First, we need to reify the loops and conditionals into the state
machine, because they affect the control flow.  Second, we need to lift any
variables that are accessed across states into the <code>State</code> enum.</p>

<p>We can also start seeing the complications.  The obvious one is mutable
variables.  We need to somehow thread the information about <code>i</code>&rsquo;s mutability
through each of the states.  This naive implementation would trip over the
<code>#[warn(unused_mut)]</code> lint.  And now you might start to get a sense of the
horror that lies beneath <code>Stateful</code>.</p>

<p>At this point, you might be thinking to yourself, &ldquo;Self, if mutable variables
are going to be complicated, what about copies and moves?&rdquo;  You sound like a
pretty sensible person.  Therein lies madness.  You might want to stop thinking
too deeply on it.  If you can&rsquo;t, maybe you think &ldquo;Wait.
What about Generics?&rdquo; Yep.  &ldquo;Borrows?!&rdquo;  Now I&rsquo;m getting a little worried.
&ldquo;How do you even know what&rsquo;s a variable!?!&rdquo;  Sorry.</p>

<p>Yeah so there are one or two things that might be a tad challenging.</p>

<hr />

<p>So that&rsquo;s <code>Stateful</code>.  It&rsquo;s an experiment to get some real world experience
with these control flow mechanisms that may someday feed into RFCs, and maybe,
just maybe, might get implemented in the compiler.  There&rsquo;s no reason we need
to support everything, which would require us to basically reimplement the
compiler.  Instead, I believe there&rsquo;s a subset of Rust that we <em>can</em> support in
order to start getting real experience now.</p>

<p>Generators area really just the start.  There&rsquo;s a whole host of other things
that really are just other things that, if you just squint at em, are really
just state machines in disguise.  It&rsquo;s quite possible if we can pull
<code>Stateful</code>, we&rsquo;ll also be able to implement things like
<a href="https://en.wikipedia.org/wiki/Coroutine">Coroutines</a>,
<a href="https://en.wikipedia.org/wiki/Continuation-passing_style">Continuations</a>, and
that hot new mechanism all the cool languages are implementing these days,
<a href="https://en.wikipedia.org/wiki/Await">Async/Await</a>.</p>

<p>But that&rsquo;s all for later.  First is to get this to work.  In closing, I leave
you with these wise words.</p>

<blockquote><p>ph&#8217;nglui mglw&#8217;nafh Cthulhu R&#8217;lyeh wgah&#8217;nagl fhtagn.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[If You Use Unsafe, You Should Be Using Compiletest]]></title>
    <link href="http://erickt.github.io/blog/2015/09/22/if-you-use-unsafe/"/>
    <updated>2015-09-22T10:58:25-07:00</updated>
    <id>http://erickt.github.io/blog/2015/09/22/if-you-use-unsafe</id>
    <content type="html"><![CDATA[<p>One of the coolest things about the Rust typesystem is that you can use it to
make unsafe bindings safe. Read all about it in the
<a href="https://doc.rust-lang.org/nightly/nomicon/">Rustonomicon</a>. However, it can be
really quite easy to slip in a bug where you&rsquo;re not actually making the
guarantees you think you&rsquo;re making. For example, here&rsquo;s a real bug I made in
the <a href="https://github.com/erickt/rust-zmq">ZeroMQ FFI bindings</a> (which have been
edited for clarity):</p>

<pre><code class="rust">pub struct Socket {
    sock: *mut libc::c_void,
    closed: bool
}

impl Socket {
    pub fn as_poll_item&lt;'a&gt;(&amp;self, events: i16) -&gt; PollItem&lt;'a&gt; { // &lt;- BUG!!!
        PollItem {
            socket: self.sock,
            fd: 0,
            events: events,
            revents: 0,
            marker: PhantomData
        }
    }
}

impl Drop for Socket {
    fn drop(&amp;mut self) {
        unsafe {
            zmq_sys::zmq_close(self.sock);
        }
    }
}

pub struct PollItem&lt;'a&gt; {
    socket: *mut libc::c_void,
    fd: libc::c_int,
    events: i16,
    revents: i16,
    marker: PhantomData&lt;&amp;'a Socket&gt;
}

pub fn poll(items: &amp;mut [PollItem], timeout: i64) -&gt; Result&lt;i32, Error&gt; {
    unsafe {
        let rc = zmq_sys::zmq_poll(
            items.as_mut_ptr() as *mut zmq_sys::zmq_pollitem_t,
            items.len() as c_int,
            timeout as c_long);

        if rc == -1i32 {
            Err(errno_to_error())
        } else {
            Ok(rc as i32)
        }
    }
}
</code></pre>

<p>Here&rsquo;s the bug if you missed my callout:</p>

<pre><code class="rust">    pub fn as_poll_item&lt;'a&gt;(&amp;self, events: i16) -&gt; PollItem&lt;'a&gt; { // &lt;- BUG!!!
</code></pre>

<p>My intention was to tie the lifetime of <code>PollItem&lt;'a&gt;</code> to the lifetime of the
<code>Socket</code>, but because I left out one measly <code>'a</code>, Rust doesn&rsquo;t tie the two
together, and instead is actually using the <code>'static</code> lifetime. This then lets
you do something evil like:</p>

<pre><code>// leak the pointer!
let poll_item = {
        let context = zmq::Context::new();
        let socket = context.socket(zmq::PAIR).unwrap();
        socket.as_poll_item(0)
};

// And use the now uninitialized pointer! Wee! Party like it's C/C++!
poll(&amp;[poll_item], 0).unwrap();
</code></pre>

<p>It&rsquo;s just that easy. Fix is simple, just change the function to use <code>&amp;'a self</code>
and Rust will refuse to compile this snippet. Job well done!</p>

<p>Well, no, not really. Because what was particularly devious about this bug is
that it actually came back. Later on I accidentally reverted <code>&amp;'a self</code> back to
<code>&amp;self</code> because I secretly hate myself. The project and examples still compiled
and ran, but that unitialized dereference was just waiting around to cause a
security vulnerability.</p>

<p>Oops.</p>

<p>Crap.</p>

<p>Making sure Rust actually rejects programs that it ought to be rejecting
<strong>fundamentally important</strong> when writing a library that uses Unsafe Rust.</p>

<p>That&rsquo;s where <a href="https://github.com/laumann/compiletest-rs">compiletest</a> comes in.
It&rsquo;s a testing framework that&rsquo;s been extacted from
<a href="https://github.com/rust-lang/rust">rust-lang/rust</a>
that lets you write these &ldquo;shouldn&rsquo;t-compile&rdquo; tests. Here&rsquo;s how to use it.
First add this to your <code>Cargo.toml</code>. We do a little feature dance because
currently <code>compiletest</code> only runs on nightly:</p>

<pre><code class="toml">...
[features]
unstable = ["compiletest_rs"]
...

[dependencies]
compiletest_rs = { "version = "*", optional = true }
...
</code></pre>

<p>Then, add add a test driver <code>tests/compile-tests.rs</code> (or whatever you want to
name it) that runs the compiletest tests:</p>

<pre><code class="rust">#![cfg(feature = "unstable")]

extern crate compiletest_rs as compiletest;

use std::path::PathBuf;
use std::env::var;

fn run_mode(mode: &amp;'static str) {
    let mut config = compiletest::default_config();

    let cfg_mode = mode.parse().ok().expect("Invalid mode");

    config.target_rustcflags = Some("-L target/debug/ -L target/debug/deps/".to_owned());
    if let Ok(name) = var::&lt;&amp;str&gt;("TESTNAME") {
        let s : String = name.to_owned();
        config.filter = Some(s)
    }
    config.mode = cfg_mode;
    config.src_base = PathBuf::from(format!("tests/{}", mode));

    compiletest::run_tests(&amp;config);
}

#[test]
fn compile_test() {
    run_mode("compile-fail");
}
</code></pre>

<p>Finally, add the test! Here&rsquo;s the one I wrote, <code>tests/compile-fail/no-leaking-poll-items.rs</code>:</p>

<pre><code class="rust">extern crate zmq;

fn main() {
    let mut context = zmq::Context::new();
    let _poll_item = {
        let socket = context.socket(zmq::PAIR).unwrap();
        socket.as_poll_item(0) //~ ERROR error: `socket` does not live long enough
    };
}
</code></pre>

<p>Now you can live in peace with the confidence that this bug won&rsquo;t ever appear again:</p>

<pre><code>% multirust run nightly cargo test --features unstable
     Running target/debug/compile_tests-335c5f56b353961f

running 1 test

running 1 test
test [compile-fail] compile-fail/no-leaking-poll-items.rs ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

test compile_test ... ok
</code></pre>

<p>In summary, use <code>compiletest</code>, and demand it&rsquo;s use from the Unsafe Rust
libraries you use! Otherwise you can never be sure if unsafe and undefined
behavior like this will sneak into your project.</p>

<p>TLDR:</p>

<p><img class="center" src="/images/compiletest-badtime.jpg" title="Bad Time" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serde 0.5.0 - Many Many Changes]]></title>
    <link href="http://erickt.github.io/blog/2015/08/07/serde-0-dot-5-0-many-many-changes/"/>
    <updated>2015-08-07T08:14:22-07:00</updated>
    <id>http://erickt.github.io/blog/2015/08/07/serde-0-dot-5-0-many-many-changes</id>
    <content type="html"><![CDATA[<p>Hello all you beautiful and talented people! I&rsquo;m pleased to announce
<a href="https://github.com/serde-rs/serde">serde</a> 0.5.0. We&rsquo;re bumping the major
(unstable) version number here because there have been a huge amount of
breaking changes in the API. This has been done to better support serialization
formats like <a href="https://github.com/TyOverby/bincode">bincode</a>, which relies on
the <code>Serialize</code>e to hint to the <code>Serializer</code> how to parse the next bytes.
This will enable <a href="https://github.com/servo/servo/pull/6583">Servo</a> to use
bincode for its IPC protocol.</p>

<p>Here are the major changes:</p>

<ul>
<li><code>serde::json</code> was factored out into its own separate crate
<a href="https://crates.io/crates/serde_json">serde_json</a>
  <a href="https://github.com/serde-rs/serde/pull/114">#114</a>.</li>
<li>Added serialization and deserialization type hints.</li>
<li>Renamed many functions to change <code>visit_named_{map,seq}</code> to
  <code>visit_struct</code> and <code>visit_tuple_struct</code>
  <a href="https://github.com/serde-rs/serde/pull/114">#114</a>
<a href="https://github.com/serde-rs/serde/pull/120">#120</a>.</li>
<li>Added hooks to allow serializers to serialize newtype tuple structs without a
wrapper type <a href="https://github.com/serde-rs/serde/pull/121">#121</a>.</li>
<li>Remove <code>_error</code> from <code>de::Error</code>
<a href="https://github.com/serde-rs/serde/pull/129">#129</a>.</li>
<li>Rewrote json parser to not consume the whole stream
<a href="https://github.com/serde-rs/serde/pull/127">#127</a>.</li>
<li>Fixed <code>serde_macros</code> for generating fully generic code
<a href="https://github.com/serde-rs/serde/pull/117">#117</a>.</li>
</ul>


<p>Thank you to everyone that&rsquo;s helped with this release:</p>

<ul>
<li>Craig Brandenburg</li>
<li>Hugo Duncan</li>
<li>Jarred Nicholis</li>
<li>Oliver Schneider</li>
<li>Patrick Walton</li>
<li>Sebastian Thiel</li>
<li>Skylar Lipthay</li>
<li>Thomas Bahn</li>
<li>dswd</li>
</ul>


<h1>Benchmarks</h1>

<p>It&rsquo;s been a bit since we last did some
<a href="https://erickt.github.io/blog/2015/02/16/rewriting-rust-serialization-there-can-be-only-one-serde/">benchmarks</a>,
so here are the latest numbers with these compilers:</p>

<ul>
<li>rustc: 1.4.0-nightly (1181679c8 2015-08-07)</li>
<li>go: version go1.4.2 darwin/amd64</li>
<li>clang: Apple LLVM version 6.1.0 (clang-602.0.53) (based on LLVM 3.6.0svn)</li>
</ul>


<p><a href="https://github.com/TyOverby/bincode">bincode</a>&rsquo;s serde support makes its first
appearance, which starts out roughly 1/3 slower at serialization, but about the
same speed at deserialization. I haven&rsquo;t done much optimization, so there&rsquo;s
probably a lot of low hanging fruit.</p>

<p><a href="https://crates.io/crates/serde_json">serde_json</a> saw a good amount of
improvement, mainly from some compiler optimizations in the 1.4 nightly. The
deserializer is slightly slower due to the parser rewrite.</p>

<p><a href="https://github.com/dwrensha/capnproto-rust">capnproto-rust</a>&rsquo;s unpacked format
shows a surprisingly large large serialization improvement, with a 10x
improvement from 4GB/s to 15GB/s. Good job dwrensha!  Deserialization is half
as slow as before though. Perhaps I have a bug in my code?</p>

<p>I&rsquo;ve changed the Rust MessagePack implementation to
<a href="https://github.com/3Hren/msgpack-rust">rmp</a>, which has a wee bit faster
serializer, but deserialization was about the same.</p>

<p>I&rsquo;ve also updated the numbers for Go and C++, but those numbers stayed roughly
the same.</p>

<p>Serialization:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library             </th>
<th> format                     </th>
<th> serialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>capnproto-rust</strong>  </td>
<td> <strong>Cap&#8217;n Proto (unpacked)</strong> </td>
<td> <del>4349</del> <strong>15448</strong>   </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto        </td>
<td> Cap&#8217;n Proto                </td>
<td> 3877                 </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>bincode</strong>         </td>
<td> <strong>Raw</strong>                    </td>
<td> <del>1020</del> <strong>3278</strong>    </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>bincode (serde)</strong> </td>
<td> <strong>Raw</strong>                    </td>
<td> <strong>2143</strong>             </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>capnproto-rust</strong>  </td>
<td> <strong>Cap&#8217;n Proto (packed)</strong>   </td>
<td> <del>583</del> <strong>656</strong>      </td>
</tr>
<tr>
<td> Go       </td>
<td> gogoprotobuf        </td>
<td> Protocol Buffers           </td>
<td> <del>596</del> 627          </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>rmp</strong>             </td>
<td> <strong>MessagePack</strong>            </td>
<td> <del>397</del> <strong>427</strong>      </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>rust-protobuf</strong>   </td>
<td> <strong>Protocol Buffers</strong>       </td>
<td> <del>357</del> <strong>373</strong>      </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serde::json</strong>     </td>
<td> <strong>JSON</strong>                   </td>
<td> <del>288</del> <strong>337</strong>      </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson           </td>
<td> JSON                       </td>
<td> 307                  </td>
</tr>
<tr>
<td> Go       </td>
<td> goprotobuf          </td>
<td> Protocol Buffers           </td>
<td> <del>214</del> 226          </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serialize::json</strong> </td>
<td> <strong>JSON</strong>                   </td>
<td> <del>147</del> <strong>212</strong>      </td>
</tr>
<tr>
<td> Go       </td>
<td> ffjson              </td>
<td> JSON                       </td>
<td> 147                  </td>
</tr>
<tr>
<td> Go       </td>
<td> encoding/json       </td>
<td> JSON                       </td>
<td> 85                   </td>
</tr>
</tbody>
</table>


<p>Deserialization:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library             </th>
<th> format                     </th>
<th> deserialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>capnproto-rust</strong>  </td>
<td> <strong>Cap&#8217;n Proto (unpacked)</strong> </td>
<td> <del>2185</del> <strong>1306</strong>      </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto        </td>
<td> Cap&#8217;n Proto (zero copy)    </td>
<td> 1407                   </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto        </td>
<td> Cap&#8217;n Proto                </td>
<td> 711                    </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>capnproto-rust</strong>  </td>
<td> <strong>Cap&#8217;n Proto (packed)</strong>   </td>
<td> <del>351</del> <strong>464</strong>        </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>bincode (serde)</strong> </td>
<td> <strong>Raw</strong>                    </td>
<td> <strong>310</strong>                </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>bincode</strong>         </td>
<td> <strong>Raw</strong>                    </td>
<td> <del>142</del> <strong>291</strong>        </td>
</tr>
<tr>
<td> Go       </td>
<td> gogoprotobuf        </td>
<td> Protocol Buffers           </td>
<td> 270                    </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson           </td>
<td> JSON (sax)                 </td>
<td> 182                    </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson           </td>
<td> JSON (dom)                 </td>
<td> 155                    </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>rust-protobuf</strong>   </td>
<td> <strong>Protocol Buffers</strong>       </td>
<td> <strong>143</strong>                </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>rmp</strong>             </td>
<td> <strong>MessagePack</strong>            </td>
<td> <del>138</del> <strong>128</strong>        </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serde::json</strong>     </td>
<td> <strong>JSON</strong>                   </td>
<td> <del>140</del> <strong>122</strong>        </td>
</tr>
<tr>
<td> Go       </td>
<td> ffjson              </td>
<td> JSON                       </td>
<td> 95                     </td>
</tr>
<tr>
<td> Go       </td>
<td> goprotobuf          </td>
<td> Protocol Buffers           </td>
<td> 81                     </td>
</tr>
<tr>
<td> Go       </td>
<td> encoding/json       </td>
<td> JSON                       </td>
<td> 23                     </td>
</tr>
<tr>
<td> Rust     </td>
<td> serialize::json     </td>
<td> JSON                       </td>
<td> 23                     </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
</feed>
