<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rust | Tilting at Rabbit Holes]]></title>
  <link href="http://erickt.github.io/blog/categories/rust/atom.xml" rel="self"/>
  <link href="http://erickt.github.io/"/>
  <updated>2014-10-28T08:58:59-07:00</updated>
  <id>http://erickt.github.io/</id>
  <author>
    <name><![CDATA[Erick Tryzelaar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rewriting Rust Serialization, Part 1]]></title>
    <link href="http://erickt.github.io/blog/2014/10/28/serialization/"/>
    <updated>2014-10-28T08:52:18-07:00</updated>
    <id>http://erickt.github.io/blog/2014/10/28/serialization</id>
    <content type="html"><![CDATA[<p>Hello everybody! It&rsquo;s been, what, <em>two</em> years since I last blogged? Not my best
performance, I&rsquo;m sorry to say. So for all of my 3 pageviews that are probably
bots, I appologize for such a long delay on updating my blog. I got to say I&rsquo;ve
been pretty inspired by the great <a href="http://jvns.ca/">Julia Evans</a> (who I hope we
can someday get back to working on rust stuff). She&rsquo;s an epic blogger, and I
hope I can get somewhere near that speed.</p>

<p>Anyway, on to the post. My main on-again-off-again project this past year has
been working Rust&rsquo;s generic <a href="http://doc.rust-lang.org/serialize/">serialize</a>
library. If you haven&rsquo;t played with it yet, it&rsquo;s really nifty. It&rsquo;s a generic
framework that allows a generic <code>Encoder</code> serialize a generic <code>Encodable</code>, and
the inverse with <code>Decoder</code> and <code>Decodable</code>. This allows you to write just one
<code>Encodable</code> impl that can transparently work with our
<a href="http://doc.rust-lang.org/serialize/">json</a> library,
<a href="https://github.com/mneumann/rust-msgpack">msgpack</a>,
<a href="https://github.com/alexcrichton/toml-rs">toml</a>, and etc. It&rsquo;s simple to use
too in most cases as you can use <code>#[deriving(Encodable, Decodable)]</code> to
automatically create a implementation for your type. Here&rsquo;s an example:</p>

<pre><code class="rust">extern crate serialize;

use serialize::json;

#[deriving(Encodable, Decodable, Show)]
struct Employee {
    name: String,
}

#[deriving(Encodable, Decodable, Show)]
struct Company {
    employees: Vec&lt;Employee&gt;,
}

fn main() {
    let company = Company {
        employees: vec![
            Employee { name: "Dan".to_string() },
            Employee { name: "Erin".to_string() },
            Employee { name: "Jeff".to_string() },
            Employee { name: "Spencer".to_string() },
        ],
    };

    let s = json::encode(&amp;company);
    let company: Company = json::decode(s.as_slice()).unwrap();
}
</code></pre>

<p>There are some downsides to serialize though. Manually implementing can be a
bit of a pain. Here&rsquo;s the example from before:</p>

<pre><code class="rust">impl&lt;S: Encoder&lt;E&gt;, E&gt; Encodable&lt;S, E&gt; for Employee {
    fn encode(&amp;self, s: &amp;mut S) -&gt; Result&lt;(), E&gt; {
        match *self {
            Employee { name: ref name } =&gt; {
                s.emit_struct("Employee", 1u, |s| {
                    s.emit_struct_field("name", 0u, |s| name.encode(s))
                })
            }
        }
    }
}

impl&lt;D: Decoder&lt;E&gt;, E&gt; Decodable&lt;D, E&gt; for Employee {
    fn decode(d: &amp;mut D) -&gt; Result&lt;Employee, E&gt; {
        d.read_struct("Employee", 1u, |d| {
            Ok(Employee {
                name: {
                    try!(d.read_struct_field("name", 0u, |d| {
                        Decodable::decode(d)
                    }))
                }
            })
        })
    }
}
</code></pre>

<p>As you can see, parsing compound structures requires these recursive closure
calls in order to perform the handshake between the <code>Encoder</code> and the
<code>Encodable</code>. A couple people have run into bugs in the past where they didn&rsquo;t
implement this pattern, which results in some confusing bugs. Furthermore, LLVM
isn&rsquo;t great at inlining these recursive calls, so <code>serialize</code> impls tend to not
perform well.</p>

<p>That&rsquo;s not the worst of it though. The real problem is that there are types
that can implement <code>Encodable</code>, there&rsquo;s no way to write a <code>Decodable</code>
implementation. They&rsquo;re pretty common too. For example, the
<code>serialize::json::Json</code> type:</p>

<pre><code class="rust">pub enum Json {
    I64(i64),
    U64(u64),
    F64(f64),
    String(string::String),
    Boolean(bool),
    List(JsonList),
    Object(JsonObject),
    Null,
}

pub type JsonList = Vec&lt;Json&gt;;
pub type JsonObject = TreeMap&lt;string::String, Json&gt;;
</code></pre>

<p>The <code>Json</code> value can represent any value that&rsquo;s in a JSON string. Implied in
this is the notion that the <code>Decodable</code> has to look ahead to see what the next
value is so it can decide which <code>Json</code> variant to construct. Unfortunately our
current <code>Decoder</code> infrastructure doesn&rsquo;t support lookahead. The way the
<code>Decoder</code>/<code>Decodable</code> handshake works is essentially:</p>

<ul>
<li><code>Decodable</code> asks for a struct named <code>"Employee"</code>.</li>
<li><code>Decodable</code> asks for a field named <code>"name"</code>.</li>
<li><code>Decodable</code> asks for a value of type <code>String</code>.</li>
<li><code>Decodable</code> asks for a field named <code>"age"</code>.</li>
<li><code>Decodable</code> asks for a value of type <code>uint</code>.</li>
<li>&hellip;</li>
</ul>


<p>Any deviation from this pattern results in an error. There isn&rsquo;t a way for the
<code>Decodable</code> to ask what is the type of the next value, so this is why we
serialize generic enums by explicitly tagging the variant, as in:</p>

<pre><code>extern crate serialize;

use serialize::json;

#[deriving(Encodable, Decodable, Show)]
enum Animal {
    Dog(uint),
    Frog(String, uint),
}

fn main() {
    let animal = Frog("Frank".to_string(), 349);

    let s = json::encode(&amp;animal);

    println!("{}", s);
    // prints {"variant":"Frog","fields":["Frank",349]}
}
</code></pre>

<p>That&rsquo;s probably good enough for now. In my next post I&rsquo;ll go into in my
approach to fix this in <a href="https://github.com/erickt/rust-serde">serde</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust for Ragel]]></title>
    <link href="http://erickt.github.io/blog/2012/07/29/rust-for-ragel/"/>
    <updated>2012-07-29T10:20:00-07:00</updated>
    <id>http://erickt.github.io/blog/2012/07/29/rust-for-ragel</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve written a bunch of simple parsers for Rust, and it&rsquo;s starting to get a
little obnoxious. So I added a Rust backend to the
<a href="http://www.complang.org/ragel/">Ragel State Machine Compiler</a>.
You can find my fork <a href="https://github.com/erickt/ragel">here</a>. I&rsquo;m waiting for
Rust to stablize before I try to push it upstream.</p>

<p>Ragel is a rather neat way of writing simple parsers. In some ways it&rsquo;s pretty
similar to Lex, but Ragel also allows you execute arbitrary code at any point
in the state machine. Furthermore, this arbitrary code can manipulate the state
machine itself, so it can be used in many places you&rsquo;d traditionally need a
full parser, such as properly handling parentheses.</p>

<p>Here&rsquo;s an example of a <code>atoi</code> function:</p>

<pre><code>%%{
machine atoi;

action see_neg   { neg = true; }
action add_digit { res = res * 10 + (fc as int - '0' as int); }

main :=
    ( '-' @see_neg | '+' )? ( digit @add_digit )+
    '\n'?
;

write data;
}%%

fn atoi(data: ~str) -&gt; option&lt;int&gt; {
    let mut neg = false;
    let mut res = 0;

    // Ragel assumes that it will be iterating over a value called data, but we
    // need to tell ragel where to start (p) and end (pe) parsing.
    let mut p = 0;
    let mut pe = data.len();

    // This is the current state in the state machine.
    let mut cs: int;

    write init;
    write exec;

    if neg { res = -1 * res; }

    // If we stopped before we hit one of the exit states, then there must have
    // been an error of some sort.
    if cs &lt; atoi_first_final {
        none
    } else {
        some(res)
    }
}
</code></pre>

<p>While this is probably a bit more verbose than writing <code>atoi</code> by hand, it does
make the grammar pretty explicit, which can help keep it accurate.</p>

<p>Unfortunately there are some pretty severe performance issues at the moment.
Ragel supports two state machine styles, table-driven and goto-driven. My
backend uses tables, but since Rust doesn&rsquo;t yet support global constant
vectors, I need to malloc the state machine table on every function call. This
results in the <a href="https://github.com/erickt/ragel/blob/rust/examples/rust/url.rl">ragel-based url
parser</a> being about
10 times slower than the equivalent table-based parser in OCaml. You can see
the generated code <a href="https://gist.github.com/3200980">here</a>.</p>

<p>The <code>goto</code> route could be promising to explore. We could simulate it using
mutually recursive function calls. OCaml does this. But again, since Rust
doesn&rsquo;t support tailcalls (and may
<a href="https://github.com/mozilla/rust/issues/217">ever</a>), we could run into a stack
explosion. It may work well for small grammars though, and maybe LLVM could
optimize calls into tailcalls.</p>

<p>Unless I&rsquo;m doing something glaringly wrong, it seems likely that we are going
to need some compiler help before these performance issues get solved.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Meal, Ready-to-Eat: A Web Framework for Rust]]></title>
    <link href="http://erickt.github.io/blog/2012/07/05/meal-ready-to-eat-a-web-framework-for-rust/"/>
    <updated>2012-07-05T08:55:00-07:00</updated>
    <id>http://erickt.github.io/blog/2012/07/05/meal-ready-to-eat-a-web-framework-for-rust</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been putting this off for far too long. For the last three months I&rsquo;ve
been working on <a href="https://github.com/erickt/mre">Meal, Ready-to-Eat</a>, a web
framework for the <a href="http://rust-lang.org">Rust programming language</a>. I call it
MRE. Rust didn&rsquo;t have a TCP stack when I started the project, so instead I
built MRE on top of <a href="http://mongrel2.org">Mongrel2</a>. It talks
<a href="http://zeromq.org">Zeromq</a>, so I could get something up pretty quickly. It&rsquo;s
inspired by <a href="http://www.sinatrarb.com/">Sinatra</a> and
<a href="http://expressjs.com/">Express.js</a>.  So take all this code with a grain of
salt. The design is very much in flux and there are some pretty rough edges.
Better to release early and get feedback though, right?</p>

<p>One word of warning though. Rust&rsquo;s syntax and semantics are still in flux, so
it&rsquo;s quite possible this blog post will be out of date by the time you read it.</p>

<h2>Hello World</h2>

<p>Let&rsquo;s start with the classic Hello World app. You can find the full example
<a href="https://github.com/erickt/mre/blob/master/examples/helloworld/helloworld.rs">here</a>.
This example is a little more verbose than frameworks like Sinatra and Express,
and not just because Rust is statically typed. Those other frameworks take
advantage of global variables and static initializers, but Rust doesn&rsquo;t, so we
have to make due with some boilerplate code.</p>

<pre><code>let mre = mre::mre(
        // Create a zeromq context that MRE will use to talk to Mongrel2.
        alt zmq::init(1) {
            ok(ctx) { ctx }
            err(e) { fail e.to_str() }
        },

        // A UUID for this Mongrel2 backend.
        some("E4B7CE14-E7F7-43EE-A3E6-DB7B0A0C106F"),

        // The addresses to receive requests from.
        ~["tcp://127.0.0.1:9996"],

        // The addresses to send responses to.
        ~["tcp://127.0.0.1:9997"],

        // Create our middleware, which preproceses requests and
        // responses. For now we'll just use the logger.
        ~[mre::middleware::logger(io::stdout())],

        // A function to create per-request data. This can be used by
        // middleware like middleware::session to automatically look
        // up the current user and session data in the database. We don't
        // need it for this example, so just return a unit value.
        || ()
);
</code></pre>

<p>Eventually I would like to pull the Mongrel2 settings out into a separate
config file, so it should get a little more slim in the future. Once we have an
<code>mre</code> value, we can define some routes.</p>

<pre><code>do mre.get("^/$") |_req, rep, _m| {
        rep.reply_html(200u,
                "&lt;html&gt;\n" +
                "&lt;body&gt;\n" +
                "&lt;h1&gt;Hello world!&lt;/h1&gt;\n" + 
                "&lt;/body&gt;\n" +
                "&lt;/html&gt;")
}
</code></pre>

<p>Routes are defined much like Sinatra. You&rsquo;ll find helpers for all the HTTP/1.1
methods. These method handlers take two arguments. The first is a PCRE regular
expression, which may have capture clauses, the second a response handler
closure. Whenever a request comes for a path that accesses this matching
handler, the closure will be called with a <code>mre::request</code>, <code>mre::response</code>, and
the regex match object. <code>mre::request</code> values, obviously, contain all the data
relevant for a given request. Most important the headers and the body.
<code>mre::response</code> values handle sending responses back to the client.</p>

<p>Finally, we start the MRE event loop, and we&rsquo;re off.</p>

<pre><code>mre.run();
</code></pre>

<h2>Models</h2>

<p>MRE also comes with a basic database support, built on top of
<a href="http://elasticsearch.org">Elasticsearch</a>. Sure it&rsquo;s technically a a fulltext
search engine, but it also works quite well as a JSON object store. Plus,
there&rsquo;s a <a href="https://github.com/tlrx/transport-zeromq">Zeromq plugin</a>, so it was
pretty easy to plug it into MRE.  The plugin can be a bit of a pain to set up,
however, so I wrote up some directions for that
<a href="https://github.com/erickt/rust-elasticsearch">here</a>.</p>

<p>Let&rsquo;s rewrite our Hello World app to be a bit more interactive. Rather than
just saying Hello World, let&rsquo;s greet anyone who asks (Source is
<a href="https://github.com/erickt/mre/blob/master/examples/helloeveryone">here</a>).
Before we begin with the MRE code, we need to create our Elasticsearch index:</p>

<pre><code>curl -XPOST "http://localhost:9200/helloeveryone" -d '{
  "settings": {
    "index.number_of_shards": 1,
    "index.number_of_replicas": 0
  },
  "mappings": {
    "person": {
      "properties": {
        "timestamp": {"type": "date", "index": "not_analyzed"},
        "name": {"type": "string", "index": "not_analyzed"}
      }
    }
  }
}'
</code></pre>

<p>Next, lets make a model of all the people we&rsquo;ll greet. At it&rsquo;s heart, a
model is just a JSON object with some helper functions. Unfortunately Rust
still has some ways to go before we can write really clean models. There is no
support for inheritance or mixin classes, so we need to duplicate some code in
all the models. Also, our constructors are not that featureful. We don&rsquo;t
support mulitple constructors, nor is there a way to make a constructor
private. Fortunately we can hack our way to the API we want.</p>

<p>So enough preamble, lets see this in action. Below is our <code>person</code> model:</p>

<pre><code>class _person {
    let model: model;

    new(model: model) {
        self.model = model;
    }

    fn id() -&gt; @str {
        self.model._id
    }

    fn timestamp() -&gt; @str {
        self.model.get_str("timestamp")
    }

    fn set_timestamp(timestamp: @str) -&gt; bool {
        self.model.set_str("timestamp", timestamp)
    }

    fn name() -&gt; @str {
        self.model.get_str("name")
    }

    fn set_name(name: @str) -&gt; bool {
        self.model.set_str("name", name)
    }

    fn create() -&gt; result&lt;(), error&gt; {
        self.model.create()
    }

    fn save() -&gt; result&lt;(), error&gt; {
        self.model.save()
    }

    fn delete() {
        self.model.delete()
    }
}

type person = _person;
</code></pre>

<p>In order to work around not having private constructors, we create a class
called <code>_person</code>, which is then aliased to <code>person</code>. If we don&rsquo;t export
<code>_person</code>, then our constructor is effectively hidden.</p>

<p>Next, here&rsquo;s how to create and find the <code>person</code> models:</p>

<pre><code>// Create a new person model.
fn person(es: client, name: @str) -&gt; person {
    // Create a person. We'll store the model in the ES index named
    // "helloeveryone", under the type "person". We'd like ES to make the index
    // for us, so we leave the id blank.
    let person = _person(model(es, @"helloeveryone", @"person", @""));

    person.set_name(name);
    person.set_timestamp(@time::now().rfc3339());

    person
}

// Return the last 50 people we have said hello to.
fn last_50(es: client) -&gt; [person] {
    // This query can be a little complicated for those who have never used
    // elasticsearch. All it says is that we want to fetch 50 documents on the
    // index "helloeveryone" and the type "person", sorted by time.
    do model::search(es) |bld| {
        bld
            .set_indices(~["helloeveryone"])
            .set_types(~["person"])
            .set_source(*json_dict_builder()
                .insert("size", 50.0)
                .insert_list("sort", |bld|
                    bld.push_dict(|bld|
                        bld.insert("timestamp", "desc");
                    });
                })
            );
    }.map(|model|
        // Construct a person model from the raw model data.
        _person(model)
    )
}
</code></pre>

<p>Here, since <code>person</code> is just a type alias, we can also create a function called
<code>person</code>. The underlying <code>_person</code> constructor then can be shared with
multiple functions, which lets us simulate having multiple constructors. So,
the users of the model have a clean api, which is exactly what we want.</p>

<p>We&rsquo;re almost done, so lets finish up and tie everything together in our <code>main</code>:</p>

<pre><code>fn main() {
    // Create a zeromq context that MRE will use to talk to Mongrel2 and
    // Elasticsearch.
    let zmq = alt zmq::init(1) {
        ok(ctx) { ctx }
        err(e) { fail e.to_str() }
    };

    let mre = mre::mre(zmq, ...);

    // Connect to Elasticsearch, which we'll use as our database.
    let es = elasticsearch::connect_with_zmq(zmq, "tcp://localhost:9700");

    // Show who we'll say hello to.
    do mre.get("^/$") |_req, rep, _m| {
        // Fetch the people we've greeted.
        let people = person::last_50(es);

        // We want to render out our responses using mustache, so we need
        // to convert our model over to something mustache can handle.
        let template = mustache::render_file("index", hash_from_strs(~[
            ("names", do people.map |person| {
                hash_from_strs(~[
                    ("name", person.name())
                ])
            }.to_mustache())
        ]));

        rep.reply_html(200u, template)
    }

    // Add a new person to greet.
    do mre.post("^/$") |req, rep, _m| {
        // Parse the form data.
        let form = uri::decode_form_urlencoded(*req.body());

        alt form.find("name") {
          none {
            rep.reply_http(400u, "missing name");
          }
          some(names) {
            // Create and save our person. If successful, redirect back to
            // the front page.
            let person = person::person(es, (*names)[0u]);

            alt person.create() {
              ok(()) { rep.reply_redirect("/") }
              err(e) {
                // Uh oh, something bad happened. Let's just display the
                // error back to the user for now.
                rep.reply_http(500u, e.msg)
              }
            }
          }
        }
    }

    // Finally, start the MRE event loop.
    mre.run();
}
</code></pre>

<h2>Middleware</h2>

<p>As you probably saw in the <code>mre::mre</code> constructor, MRE has some basic
support for middleware. Creating middleware is pretty easy. It&rsquo;s just a
function that matches this interface (That type variable matches the return
type for the closure passed in to <code>mre::mre</code>):</p>

<pre><code>type middleware&lt;T&gt; = fn@(@request&lt;T&gt;, @response) -&gt; bool;
</code></pre>

<p>Middleware gets called on each request in order, and is able to
read the request and it&rsquo;s headers, and modify the response hooks. Here&rsquo;s
<code>mre::middleware::logger</code>, to show how it works:</p>

<pre><code>fn logger&lt;T: copy&gt;(logger: io::writer) -&gt; middleware&lt;T&gt; {
    |req: @request&lt;T&gt;, rep: @response| {
        let old_end = rep.end;
        rep.end = || {
            let address = alt req.find_header("x-forwarded-for") {
              none { @"-" }
              some(address) { address }
            };

            let method = alt req.find_header("METHOD") {
              none { @"-" }
              some(method) { method }
            };

            let len = alt rep.find_header("Content-Length") {
              none { @"-" }
              some(len) { len }
            };

            logger.write_line(#fmt("%s - %s [%s] \"%s %s\" %u %s",
                *address,
                "-",
                time::now().strftime("%d/%m/%Y:%H:%M:%S %z"),
                *method,
                *req.path(),
                rep.code,
                *len));

            old_end();
        };

        true
    }
}
</code></pre>

<p>MRE also includes a <code>mre::middleware::session</code> middleware, which implements a
traditional cookie-based session authentication scheme. This one is
unfortunately a little more complicated to use. Starting off, you need to
create a new datatype to store the session data and give a constructor to <code>mre</code>
on how to make this per-request data:</p>

<pre><code>type data = @{
    mut session: option&lt;mre::session::session&gt;,
    mut user: option&lt;mre::user::user&gt;,
};

let middleware = ~[
        mre::middleware::logger(io::stdout()),
        mre::middleware::session(es,
                @"blog",
                @"blog",
                @"session",
                |req: @request&lt;data&gt;, session, user| {
                        req.data.session = some(session);
                        req.data.user = some(user);
                }
        )
];

let mre = mre::mre(zmq,
        some("F0D32575-2ABB-4957-BC8B-12DAC8AFF13A"),
        ~["tcp://127.0.0.1:9998"],
        ~["tcp://127.0.0.1:9999"],
        middleware,
        || @{ mut session: none, mut user: none }
);
</code></pre>

<p>Then you access this data through the <code>request.data</code> member:</p>

<pre><code>do app.post("^/$") |req, rep, _m| {
    let id = alt req.user {
      none { @"world" }
      some(user) { user.id() }
    };

        rep.reply_html(200u,
                "&lt;html&gt;\n" +
        "&lt;body&gt;\n" +
        "&lt;h1&gt;Hello " + *id + "!&lt;/h1&gt;\n" + 
        "&lt;/body&gt;\n" +
        "&lt;/html&gt;")
}
</code></pre>

<p>See the <a href="https://github.com/erickt/mre/tree/master/examples/blog">blog</a> for a
complete example.</p>
]]></content>
  </entry>
  
</feed>
